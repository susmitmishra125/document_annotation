{
  "name" : "2021.acl-long.295.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Making Pre-trained Language Models Better Few-shot Learners",
    "authors" : [ "Tianyu Gao", "Adam Fisch", "Danqi Chen" ],
    "emails" : [ "tianyug@cs.princeton.edu", "danqic@cs.princeton.edu", "fisch@csail.mit.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing, pages 3816–3830\nAugust 1–6, 2021. ©2021 Association for Computational Linguistics\n3816"
    }, {
      "heading" : "1 Introduction",
      "text" : "The GPT-3 model (Brown et al., 2020) has made waves in the NLP community by demonstrating astounding few-shot capabilities on myriad language understanding tasks. Given only a natural language prompt and a few demonstrations of the task, GPT-3 is able to make accurate predictions without updating any of the weights of its underlying lan-\n*The first two authors contributed equally. 1Alternatively, language models’ best friends forever. 2Our implementation is publicly available at https://\ngithub.com/princeton-nlp/LM-BFF.\nguage model. However, while remarkable, GPT-3 consists of 175B parameters, which makes it challenging to use in most real-wold applications.\nIn this work, we study a more practical scenario in which we only assume access to a moderatelysized language model such as BERT (Devlin et al., 2019) or RoBERTa (Liu et al., 2019), and a small number of examples (i.e., a few-shot setting), which we can use to fine-tune the weights of the language model. This setting is appealing as (1) such models can be trained on typical research hardware; (2) few-shot settings are realistic, as it is generally both easy to acquire a few annotations (e.g., 32 examples) and efficient to train on them; and (3) updating parameters typically leads to better performance. Inspired by GPT-3’s findings, we propose several novel strategies for expanding its few-shot learning abilities to our setting, considering both classification and—for the first time—regression.\nFirst, we follow the route of prompt-based prediction, first developed by the GPT series (Radford et al., 2018, 2019; Brown et al., 2020) for zero-shot prediction and recently studied by PET (Schick and Schütze, 2021a,b) for fine-tuning. Prompt-based prediction treats the downstream task as a (masked) language modeling problem, where the model directly generates a textual response (referred to as a label word) to a given prompt defined by a taskspecific template (see Figure 1(c)). Finding the right prompts, however, is an art—requiring both domain expertise and an understanding of the language model’s inner workings. Even if significant effort is invested, manual prompts are likely to be suboptimal. We address this issue by introducing automatic prompt generation, including a pruned brute-force search to identify the best working label words, and a novel decoding objective to automatically generate templates using the generative T5 model (Raffel et al., 2020)—all of which only require the few-shot training data. This allows us\nto cheaply obtain effective prompts that match or outperform our manually chosen ones.\nSecond, we adopt the idea of incorporating demonstrations as additional context. GPT-3’s naive “in-context learning” paradigm picks up to 32 randomly sampled examples, and concatenates them with the input. This method is not guaranteed to prioritize the most informative demonstrations, and mixing random examples from different classes together creates long contexts which can be hard to learn from. Additionally, the number of usable demonstrations is bounded by the model’s maximum input length. We develop a more refined strategy, where, for each input, we randomly sample a single example at a time from each class to create multiple, minimal demonstration sets. We also devise a novel sampling strategy that pairs inputs with similar examples, thereby providing the model with more discriminative comparisons.\nWe present a systematic evaluation for analyzing few-shot performance on 8 single-sentence and 7 sentence-pair NLP tasks. We observe that given a small number of training examples, (1) promptbased fine-tuning largely outperforms standard finetuning; (2) our automatic prompt search method matches or outperforms manual prompts; and (3) incorporating demonstrations is effective for finetuning, and boosts few-shot performance. Together, these simple-yet-effective methods contribute towards a dramatic improvement across the tasks we evaluate on, and we obtain gains up to 30% absolute improvement (11% on average) compared to standard fine-tuning. For instance, we find that a RoBERTa-large model achieves around 90% accuracy on most binary sentence classification tasks,\nwhile only relying on 32 training examples. We refer to our approach as LM-BFF, better few-shot fine-tuning of language models: a strong, taskagnostic method for few-shot learning."
    }, {
      "heading" : "2 Related Work",
      "text" : "Language model prompting. The GPT series (Radford et al., 2018, 2019; Brown et al., 2020) fueled the development of prompt-based learning, and we follow many of its core concepts. We are also greatly inspired by the recent PET work (Schick and Schütze, 2021a,b), although they mainly focus on a semi-supervised setting where a large set of unlabeled examples are provided. We only use a few annotated examples as supervision, and also explore automatically generated prompts and fine-tuning with demonstrations. Furthermore, we deviate from their evaluation by providing a more rigorous framework, as we will discuss in §3. Finally, there is a large body of work on prompting for mining knowledge from pre-trained models (Trinh and Le, 2018; Petroni et al., 2019; Davison et al., 2019; Talmor et al., 2020, inter alia). Different from these works, we focus on leveraging prompting for fine-tuning on downstream tasks.\nAutomatic prompt search. Schick and Schütze (2021a) and Schick et al. (2020) explore ways of identifying label words automatically, however, none of these results lead to better performance compared to hand-picked ones. In contrast, our method searches over both templates and label words, and is able to match or outperform our manual prompts. Several other attempts have been made in addition—yet these approaches either op-\nerate in limited domains, such as finding patterns to express specific relations (Jiang et al., 2020), or require a large number of examples for gradientguided search (Shin et al., 2020; Zhong et al., 2021). Our approach aims to develop general-purpose search methods that rely only on a few annotations.\nFine-tuning of language models. A number of recent studies have focused on better methods for fine-tuning language models (Howard and Ruder, 2018; Dodge et al., 2020; Lee et al., 2020; Zhang et al., 2021). These works mainly focus on optimization and regularization techniques to stabilize fine-tuning. Here we use standard optimization techniques, and instead mainly focus our efforts on better prompt-based fine-tuning in a more extreme few-shot setting. We anticipate that results of these studies are largely complementary to ours.\nFew-shot learning. Broadly speaking, our setting is also connected to other few-shot learning paradigms in NLP, including (1) semi-supervised learning (Miyato et al., 2017; Xie et al., 2020; Chen et al., 2020), where a set of unlabeled examples are given; (2) meta-learning (Yu et al., 2018; Han et al., 2018; Bansal et al., 2020a,b; Bao et al., 2020), where a set of auxiliary tasks are given; and (3) intermediate training (Phang et al., 2018; Yin et al., 2020), where a related, intermediate task is given. We deviate from these settings by making minimal assumptions about available resources: we only assume a few annotated examples and a pre-trained language model. Our focus is on understanding how far we can push without any other advantages."
    }, {
      "heading" : "3 Problem Setup",
      "text" : "Task formulation. In this work, we assume access to a pre-trained language model L that we wish to fine-tune on a task D with a label space Y . For the task, we only assume K training examples per class3 for the task’s training set Dtrain, such that the total number of examples is Ktot = K × |Y|, and Dtrain = {(xiin, yi)} Ktot i=1. Our goal is then to develop task-agnostic learning strategies that generalize well to an unseen test set (xtestin , y\ntest) ∼ Dtest. For model selection and hyper-parameter tuning, we assume a development setDdev, of the same size as the few-shot training set, i.e., |Ddev| = |Dtrain|. This distinction is important: using a larger development set confers a significant advantage (see our\n3For regression, we partition the data into two “classes” according to being above or below the median value.\nexperiments in Appendix A), and subverts our initial goal of learning from limited data.4 For all of the following experiments (unless specified otherwise), we take L = RoBERTa-large and K = 16.\nEvaluation datasets. We conduct a systematic study across 8 single-sentence and 7 sentence-pair English tasks, including 8 tasks from the GLUE benchmark (Wang et al., 2019), SNLI (Bowman et al., 2015), and 6 other popular sentence classification tasks (SST-5, MR, CR, MPQA, Subj, TREC). All of the dataset details are provided in Appendix B. For single-sentence tasks, the goal is to make a prediction based on an input sentence xin = x1, such as whether a movie review is positive or not. For sentence-pair tasks, the goal is to take a pair of input sentences xin = (x1, x2) and predict the relationship between them. We also interchangeably refer to the inputs as <S1> or (<S1>, <S2>). Note that we mainly use SST-2 and SNLI for pilot experiments and model development, making it close to a true few-shot setting, at least for all the other datasets we evaluate on.\nEvaluation protocol. Systematically evaluating few-shot performance can be tricky. It is wellknown that fine-tuning on small datasets can suffer from instability (Dodge et al., 2020; Zhang et al., 2021), and results may change dramatically given a new split of data. To account for this, we measure average performance across 5 different randomly sampled Dtrain and Ddev splits. This issue has also been discussed in Schick and Schütze (2021b)— they suggest using a fixed set of training examples. We argue that sampling multiple splits gives a more robust measure of performance, and a better estimate of the variance. We also observe that hyperparameters can make a significant difference, thus we sweep multiple hyper-parameters for each data sample, and take the best setting as measured on the Ddev of that sample (see Appendix C.1)."
    }, {
      "heading" : "4 Prompt-based Fine-tuning",
      "text" : "Given a masked language model L, we first convert input xin to a token sequence x̃, and the language model L then maps x̃ to a sequence of hidden vectors {hk ∈ Rd}. During standard finetuning, we usually take x̃single = [CLS]x1[SEP] or x̃pair = [CLS]x1[SEP]x2[SEP]. For down-\n4In contrast, Schick and Schütze (2021a,b) do not use a development set, and adopt a set of hyper-parameters based on practical considerations. This is akin to “shooting in the dark” on a setting that we show can have unintuitive outcomes.\nstream classification tasks with a label space Y , we train a task-specific head, softmax(Woh[CLS]), by maximizing the log-probability of the correct label, where h[CLS] is the hidden vector of [CLS], and Wo ∈ R|Y|×d is a set of randomly initialized parameters introduced at the start of fine-tuning. Similarly, for a regression task, we can introduce wo ∈ Rd and optimize the mean squared error between wo ·h[CLS] and the gold label. In either case, the number of new parameters can be substantial— for example, a simple binary classification task will introduce 2,048 new parameters for a RoBERTalarge model—making it challenging to learn from a small amount of annotated data (e.g., 32 examples).\nAn alternative approach to solving this problem is prompt-based fine-tuning, in which L is directly tasked with “auto-completing” natural language prompts. For instance, we can formulate a binary sentiment classification task using a prompt with input x1 (e.g., “No reason to watch it .”) as:\nxprompt = [CLS] x1 It was [MASK] . [SEP]\nand let L decide whether it is more appropriate to fill in “great” (positive) or “terrible” (negative) for [MASK]. We now formalize this approach for classification and regression (§4.1 and §4.2), and discuss the importance of prompt selection (§4.3)."
    }, {
      "heading" : "4.1 Classification",
      "text" : "Let M : Y → V be a mapping from the task label space to individual words5 in the vocabulary\n5More generally, we can consider a one-to-many mapping M : Y → 2|Y| in which we map labels to sets of words. However, we did not find significant gains in our experiments.\nV of L. Then for each xin, let the manipulation xprompt = T (xin) be a masked language modeling (MLM) input which contains one [MASK] token. In this way, we can treat our task as an MLM, and model the probability of predicting class y ∈ Y as:\np(y | xin) = p ([MASK] =M(y) | xprompt)\n= exp\n( wM(y) · h[MASK] )∑ y′∈Y exp ( wM(y′) · h[MASK]\n) , (1) where h[MASK] is the hidden vector of [MASK] and wv denotes the pre-softmax vector corresponding to v ∈ V . When supervised examples {(xin, y)} are available, L can be fine-tuned to minimize the cross-entropy loss. It is important to note that this approach re-uses the pre-trained weights wv and does not introduce any new parameters. It also reduces the gap between pre-training and fine-tuning, making it more effective in few-shot scenarios."
    }, {
      "heading" : "4.2 Regression",
      "text" : "We assume the same basic setup as in classification, but treat the label space Y as a bounded interval [vl, vu]. Inspired by Mettes et al. (2019), we model the problem as an interpolation between two opposing poles, {yl, yu}, with values vl and vu respectively. For instance, we can formulate our previous sentiment analysis task as a regression problem in the range [0, 1], where we slide between “terrible” (vl = 0) and “great” (vu = 1). In this way, we can express y as a mixture model:\ny = vl · p(yl | xin) + vu · p(yu | xin), (2)\nwhere p(yu | xin) is the probability of yu, and p(yl | xin) = 1 − p(yu | xin). Then we define\nM : {yl, yu} → V , and model p(yu | xin) the same as Eq. (1). We fine-tune L to minimize the KL-divergence between the inferred p(yu | xin) and the observed mixture weight, (y−vl)/(vu−vl)."
    }, {
      "heading" : "4.3 Manual prompts: the good and the bad",
      "text" : "The key challenge is to construct the template T and label wordsM(Y)—we refer to these two together as a prompt P . Previous works (Schick and Schütze, 2021a,b) hand-craft both the templates and label words, which usually requires domain expertise and trial-and-error. Table 1 summarizes manual templates and label words chosen for each dataset in our experiments. These templates and label words were designed by intuition, and by considering formats used in previous literature.\nTo better understand what constitutes a good template or label word, we conduct a pilot study on SST-2 and SNLI. Table 2 shows that different prompts can lead to substantial differences in final accuracy. Specifically, when a template is fixed, the better the label words match the “semantic classes”, the better the final accuracy is (great/terrible > good/bad > cat/dog). In extreme cases where we swap plausible label words (e.g., terrible/great), we achieve the worst overall performance.6 Furthermore, with the same set of label words, even a small change in the template can make a difference. For example, for SNLI, if we put [MASK] at the end, or swap sentence order, we observe a >10% drop. The above evidence clearly underlines the\n6It is unclear, however, why RoBERTa thinks that “cat” is more positive than “dog”. The authors tend to disagree.\nimportance of selecting good templates and label words. Searching for prompts, however, is hard, as the search space can be very large—especially for the template. Even worse, we only have a few examples to use to guide our search, which can easily overfit. We will address these issues next."
    }, {
      "heading" : "5 Automatic Prompt Generation",
      "text" : "We now explore principled ways of automating the search process for label words (§5.1) and templates (§5.2). Our goals are to reduce the human involvement required to design prompts, and to find more optimal settings than those that we manually choose. Here, we assume a classification task, but the process for regression is analogous."
    }, {
      "heading" : "5.1 Automatic selection of label words",
      "text" : "We first study how to construct a label word mappingM that maximizes accuracy on Ddev after fine-tuning, given a fixed template T . Naively searching all possible assignments, however, is (1) generally intractable, as the search space is exponential in the number of classes; and (2) prone to overfitting, as we will tend to uncover spurious correlations given only a few annotations. As a simple solution, for each class c ∈ Y , we construct a pruned set Vc ⊂ V of the top k vocabulary words based on their conditional likelihood using the initial L. That is, let Dctrain ⊂ Dtrain be the subset of all examples of class c. We take Vc as\nTop-k v∈V  ∑ xin∈Dctrain logPL ( [MASK] = v | T (xin) ) , (3) where PL denotes the output probability distribution of L. To further narrow down the search space, we find the top n assignments over the pruned space that maximize zero-shot accuracy on Dtrain (both n and k are hyper-parameters, see Appendix C.2). Then we fine-tune all top n assignments, and rerank to find the best one using Ddev. This approach is similar to the automatic verbalizer search methods in Schick and Schütze (2021a); Schick et al. (2020), except that we use a much simpler search process (brute-force) and also apply re-ranking— which we find to be quite helpful."
    }, {
      "heading" : "5.2 Automatic generation of templates",
      "text" : "Next, we study how to generate a diverse set of templates {T } automatically from a fixed set of label words M(Y). To address this challenging problem, we propose to use T5 (Raffel et al., 2020),\na large pre-trained text-to-text Transformer. T5 is pre-trained to fill in missing spans (replaced by T5 mask tokens, e.g., <X> or <Y>) in its input. For example, given the input “Thank you <X> me to your party <Y> week”, T5 is trained to generate “<X> for inviting <Y> last <Z>”, meaning that “for inviting” is the replacement for <X> and “last” is the replacement for <Y>. This is well suited for prompt generation: we can simply take input sentences from Dtrain and let the T5 model construct the template T , without having to specify a predefined number of tokens for it.\nGiven an input example (xin, y) ∈ Dtrain, we consider the following simple conversions, denoted as Tg(xin, y), for formulating the T5 model inputs:7\n<S1> −→ <X>M(y) <Y> <S1>, <S1> −→ <S1> <X>M(y) <Y>,\n<S1>,<S2> −→ <S1> <X>M(y) <Y> <S2>.\nAs shown in Figure 2, we rely on the T5 model to fill in the placeholders. When decoding, our goal here is to find an output that can work well for all examples in Dtrain, i.e., the output template T that maximizes ∑ (xin,y)∈Dtrain logPT5(T | Tg(xin, y)), where PT5 denotes the output probability distribution of T5. It can be decomposed according to:\n|T |∑ j=1 ∑ (xin,y)∈Dtrain logPT5 ( tj | t1, ..., tj−1, Tg ( xin, y )) , (4)\nwhere (t1, . . . , t|T |) are the template tokens. We use beam search to decode multiple template candidates. Concretely, we use a wide beam width (e.g., 100) to cheaply obtain a large set of diverse templates. We then fine-tune each generated template onDtrain and useDdev to either pick the single template with the best performance (Table 3), or\n7We consider putting the label word both before and after the input sentence for single-sentence tasks. However, we find that it is always better to put the label words in the middle (between the two sentences) for sentence-pair tasks.\nthe top k templates to use as an ensemble (Table 4). Though it might appear to be expensive to fine-tune the model on each individual template, this is fast in practice due to the small size ofDtrain, and is also fully automated: making it easy to use, compared to manually tuning prompts for each dataset."
    }, {
      "heading" : "6 Fine-tuning with Demonstrations",
      "text" : "In this section, we study whether we can leverage demonstrations when fine-tuning medium-sized LMs, and find better ways to exploit them."
    }, {
      "heading" : "6.1 Training examples as demonstrations",
      "text" : "GPT-3’s naive approach to in-context learning simply involves concatenating the input with up to 32 examples randomly drawn from the training set. This approach is suboptimal as (1) the number of available demonstrations is bounded by the model’s maximum input length;8 and (2) mixing numerous random examples from different classes together creates extremely long contexts which can be hard to leverage, especially for a smaller model. To address these issues, we propose a simpler solution: at each training step, we randomly sample one9 example ( x (c) in , y\n(c)) ∈ Dtrain from each class, convert it into T ( x (c) in ) with [MASK] replaced by\nM(y(c))—we denote this as T̃ ( x (c) in , y (c))—and then concatenate them with xin (Figure 1(c)):\nT ( xin ) ⊕ T̃ ( x (1) in , y (1))⊕ · · · ⊕ T̃ (x(|Y|)in , y(|Y|)). Here ⊕ denotes concatenation of input sequences. During both training and inference we sample multiple demonstration sets for each xin. Note that both xin and demonstration examples are sampled from the same set Dtrain during training. At testing time, we still sample demonstration sets fromDtrain and ensemble predictions across all sets."
    }, {
      "heading" : "6.2 Sampling similar demonstrations",
      "text" : "We observe that controlling the construction of the demonstration examples {(x(c)in , y (c) )} is crucial for good final performance. For example, if the set of contrastive demonstrations x(c)in are all dramatically different—from each other, or from the query xin—then it becomes challenging for the language model to decipher meaningful patterns. As a result, the model may simply ignore\n8GPT-3 uses a context size of 2,048 while most smaller language models (e.g., RoBERTa) have a context size of 512.\n9We also explored sampling multiple examples per class, but did not observe any improvements.\nthe context, or even get confused by the additional examples. To address this issue, we devise a simple strategy in which we only sample examples that are semantically close to xin. Specifically, we use a pre-trained SBERT (Reimers and Gurevych, 2019) model to obtain embeddings for all input sentences (for sentence-pair tasks, we use the concatenation of the two sentences). Here we just feed the raw sentences without the templates into SBERT. For each query xin and each label c ∈ Y , we sort all training instances with the label x ∈ Dctrain by their similarity score to the query cos(e(xin), e(x)), and only sample from the top r = 50% instances for each class to use as demonstrations."
    }, {
      "heading" : "7 Experiments",
      "text" : "We present our main results, and address several research questions pertaining to our LM-BFF approach. Implementation details are in Appendix C."
    }, {
      "heading" : "7.1 Main results",
      "text" : "We use a RoBERTa-large model and set K = 16 in our experiments. A comparison of using RoBERTa vs BERT can be found in Appendix D. For automatic prompt search, in our main table\nwe report automatic template search only (which consistently performs the best, see Table 5). To put our results in perspective, we compare to a number of baselines, namely (1) standard fine-tuning in our few-shot setting; (2) standard fine-tuning using the full training set; (3) simply taking the most frequent class (measured on the full training set); (4) prompt-based zero-shot prediction where we take our manual prompts and use L “out-of-thebox” without using any training examples; and (5) “GPT-3” in-context learning, where we use the same prompt-based zero-shot setting, but augment the context with randomly sampled 32 demonstrations (and still use RoBERTa-large, not GPT-3).\nSingle-prompt results. Table 3 shows our main results using a single prompt, either from our manually designed ones (Table 1) , or the best generated ones. First, prompt-based zero-shot prediction achieves much better performance than the majority class, showing the pre-encoded knowledge in RoBERTa. Also, “GPT-3” in-context learning does not always improve over zero-shot prediction, likely because smaller language models are not expressive enough to use off-the-shelf like GPT-3.\nSecond, prompt-based fine-tuning can greatly outperform standard fine-tuning, both when using a manual prompt or a generated one. CoLA is one interesting exception, as the input may be a nongrammatical sentence which is out of the distribution of L. Generally, our automatically searched templates can achieve comparable or even higher results than manual ones, especially for tasks in which constructing strong manual templates is less intuitive (e.g., TREC, QNLI and MRPC).\nFinally, using demonstrations in context leads to consistent gains in a majority of tasks. In summary, our combined solution—fine-tuning with automatically searched templates and sampled demonstration sets—achieves a 30% gain on SNLI compared to standard fine-tuning, and 11% gain on average.\nEnsemble results. An advantage of automatic prompt search is that we can generate as many prompts as we want, train individual models, and create large ensembles. PET (Schick and Schütze, 2021a,b) also ensembles multiple models trained with manual prompts.10 In Table 4, we make a direct comparison of our searched prompts and PET’s manual prompts on MNLI and RTE (two\n10They then use unlabeled data and distillation to get a single model, which is outside of our scope.\ndatasets that we evaluate in common).11 As the results show, an ensemble with multiple templates always improves performance. An ensemble of the same number of automatic templates achieves comparable or better performance than the ensemble of PET’s manual prompts. Increasing the number of automatic templates brings further gains."
    }, {
      "heading" : "7.2 Analysis of generated prompts",
      "text" : "Table 5 gives the results of using manual vs automatic prompts. For automatic prompts, we compare template search (Auto T), label word search (Auto L), and a joint variant (Auto T + L) in which we start from manual label words, apply Auto T, and then Auto L. In most cases, Auto T achieves comparable or higher performance than manual ones, and is consistently the best variant. Auto L outperforms manual prompts on TREC and MRPC—but is considerably worse on SNLI. Auto T + L is often better than Auto L, but only sometimes better than Auto T. Table 6 shows examples from Auto T and Auto L (A full list in Appendix E). Auto T templates generally fit the context and label words well, but can contain biased peculiarities (e.g., “{Yes/No}, no” in SNLI). For Auto L words, things are mixed: while most look intuitively reasonable, there are also some mysterious abnormalities (e.g., “Hi” for the “entailment” class in SNLI).\n11In the PET NLI templates, the hypothesis is put before the premise, which we actually found to be suboptimal. In our experiments, we swap the two and get better results."
    }, {
      "heading" : "7.3 Analysis of demonstration sampling",
      "text" : "Table 7 compares the performance of demonstrations using uniform sampling to selective sampling by SBERT. We acknowledge that SBERT is trained on SNLI and MNLI datasets, thus we also tried a simple sentence encoder using mean pooling of hidden representations from RoBERTa-large. We find that in either case, using selective sampling outperforms uniform sampling, highlighting the importance of sampling similar examples for incorporating demonstrations in context."
    }, {
      "heading" : "7.4 Sample efficiency",
      "text" : "Figure 3 illustrates how standard fine-tuning and our LM-BFF compare as K increases. For a simple task such as SST-2 (also see MR, CR and MPQA in Table 3), despite using only 32 total examples, LMBFF has already nearly saturated its performance and is comparable to standard fine-tuning over the entire dataset. On the harder task of SNLI, LMBFF continues to improve as K increases while still maintaining a performance gap over standard finetuning, until the two converge around K = 256."
    }, {
      "heading" : "8 Discussion",
      "text" : "Reformulating NLP tasks as MLM has exciting implications for few-shot learning, but also has limitations. First, while LM-BFF greatly outperforms standard fine-tuning, Table 3 shows that, overall, the performance still substantially lags behind finetuning with thousands of examples, especially for harder tasks. Additionally, just like standard finetuning, our results also suffer from high variance. As described in §2, several recent studies have tried to counter instability in few-shot fine-tuning and we expect these methods to also help here.\nWith respect to automatic prompt generation, despite its effectiveness, we still find it practically challenging to expand the search space, or generalize well based on only approximately 32 examples.\nThis is partly due to our lingering reliance on some manual design—either manual templates (for label word search) or manual label words (for template search), which allows us to get our search off the ground, but does also bias it towards areas of the search space that we might have already imagined.\nFinally, it is important to clarify that LM-BFF favors certain tasks which (1) can be naturally posed as a “fill-in-the-blank” problem; (2) have relatively short input sequences; and (3) do not contain many output classes. Issues (2) and (3) might be ameliorated with longer-context language models (e.g., Beltagy et al., 2020). For tasks that are not straightforward to formulate in prompting, such as structured prediction, issue (1) is more fundamental. We leave it as an open question for future work."
    }, {
      "heading" : "9 Conclusion",
      "text" : "In this paper we presented LM-BFF, a set of simple but effective techniques for fine-tuning language models using only a few examples. Our approach proposes to (1) use prompt-based finetuning with automatically searched prompts; and (2) include selected task demonstrations (training examples) as part of the input context. We show that our method outperforms vanilla fine-tuning by up to 30% (and 11% on average). We concluded by discussing the limitations of our approach, and posed open questions for future study."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We thank the members of Princeton, MIT, Tsinghua NLP groups and the anonymous reviewers for their valuable feedback. TG is supported by a Graduate Fellowship at Princeton University and AF is supported by an NSF Graduate Research Fellowship. This research is also partly supported by a Google Research Scholar Award."
    }, {
      "heading" : "B Datasets",
      "text" : "For SNLI (Bowman et al., 2015) and datasets from GLUE (Wang et al., 2019), including SST2 (Socher et al., 2013), CoLA (Warstadt et al., 2019), MNLI (Williams et al., 2018), QNLI (Rajpurkar et al., 2016), RTE (Dagan et al., 2005; Bar Haim et al., 2006; Giampiccolo et al., 2007; Bentivogli et al., 2009), MRPC (Dolan and Brockett, 2005), QQP12 and STS-B (Cer et al., 2017), we follow Zhang et al. (2021) and use their original development sets for testing. For datasets which require a cross-validation evaluation—MR (Pang and Lee, 2005), CR (Hu and Liu, 2004), MPQA (Wiebe et al., 2005), Subj (Pang and Lee, 2004)—we simply randomly sample 2,000 examples as the testing set and leave them out from training. For SST5 (Socher et al., 2013) and TREC (Voorhees and Tice, 2000), we use their official test sets. We show dataset statistics in Table B.1."
    }, {
      "heading" : "C Experimental Details",
      "text" : "C.1 Hyper-parameter selection\nFor grid search, we take learning rates from {1e5, 2e-5, 5e-5} and batch sizes from {2, 4, 8}. These\n12https://www.quora.com/q/quoradata/\nnumbers are picked by pilot experiments on the SST-2 and SNLI datasets. We also use early stopping to avoid overfitting. For each trial, we train the model for 1,000 steps, validate the performance every 100 steps, and take the best checkpoint.\nC.2 Prompt-based fine-tuning\nTable 1 shows all the manual templates and label words we use in experiment. For automatically template generation, we take the T5-3B13 model, which is the largest publicly available one that can fit on a single GPU. For automatically searching label words, we set k to 100 for all tasks except SST-5 and TREC. For SST-5 we set a smaller k = 30, as it is a 5-way classification task. For TREC, we observe that filtering Vc using conditional likelihood alone is still noisy, thus we set k = 1000, and then re-rank Vc by the nearest neighbors of the original manual label words and take the top 30 per class. We set n to 100 in all experiments. Due to the large number of trials in automatic search, we take a fixed set of hyper-parameters in this part: batch size of 8 and learning rate of 1e-5.\nSince the idea of prompt-based fine-tuning is to make the input and output distribution close to the pre-training, the implementation details are crucial. For templates, we put extra space before sentences if it is not at the beginning of the input. Also, we lowercase the first letter of the sentence if it is concatenated with a prefix (e.g., <S2> in Table 1). Also if one sentence is appended any punctuation (e.g., <S1> in Table 1), then the last character of the original sentence is discarded. Finally, we prepend a space for label words in M(Y). For example, we use “ great” instead of “great” in the RoBERTa vocabulary, where “ ” stands for space.\nC.3 Fine-tuning with demonstrations\nWhen using demonstrations, we sample 16 different sets of demonstrations for each input and average the predicted log probability for each class during inference. We find that further increasing the number of samples does not bring substantial improvement. Additional, we have tried different aggregation methods like taking the result with the maximum confidence and we did not find a meaningful improvement. For selective demonstrations, we take roberta-large-nli-stsb\n13We take the T5 1.0 checkpoint, which is trained on both unsupervised and downstream task data. We compared it to T5 1.1 (without downstream task data) and did not find a significant difference in generated templates.\nmean-tokens14 from Reimers and Gurevych (2019) as our sentence embedding model."
    }, {
      "heading" : "D Comparisons of BERT vs RoBERTa",
      "text" : "Table D.1 compares the results of BERT-large (uncased) and RoBERTa-large in our settings. Pretrained BERT provides two segment embeddings (A/B) for different parts of input. The common practice, when fine-tuning BERT, is that using only segment A for single-sentence tasks, and using segment A/B for the two sentences in sentence-pair tasks. In our case of incorporating demonstrations, however, we have more than two sentences. Thus we explore the following different strategies for segments: (1) using the A segment for all sentences\n14https://github.com/UKPLab/ sentence-transformers\n(1-seg); (2) using the A segment for the original input and the B segment for the demonstrations (2-seg); (3) using different segment embeddings for each sentence (n-seg), e.g., for SNLI, we use different segments for each premise and hypothesis in both the original input and the demonstrations, which leads to a total number of 8 segment embeddings. This introduces new segment embeddings (randomly initialized and learned during fine-tuning) as the pre-trained BERT only has two.\nTable D.1 shows that prompt-based fine-tuning with demonstrations also works for BERT, and 2- seg works the best when incorporating demonstrations. Still, we take RoBERTa-large as our main model, for RoBERTa performs much better than BERT and RoBERTa saves the trouble to tune the usage of segment embeddings."
    }, {
      "heading" : "E Generated Prompts",
      "text" : "We demonstrate the top 3 automatically generated templates and label words for all tasks in Table E.1. In general, most automatic templates are reasonable and grammatically correct. For the label words, the generated results look intuitive for most single sentence tasks. For other tasks, the automatic ones can be counterintuitive in some cases. It is still unclear why the language model picks these words and sometimes they actually work well. We leave this for future study.\nTask Auto template Auto label words\nSST-2 (positive/negative) <S1> A [MASK] one . irresistible/pathetic <S1> A [MASK] piece . wonderful/bad <S1> All in all [MASK] . delicious/bad SST-5 (very positive/positive/neutral/negative/very negative) <S1> The movie is [MASK] . wonderful/remarkable/hilarious/better/awful <S1> The music is [MASK] . wonderful/perfect/hilarious/better/awful <S1> But it is [MASK] . unforgettable/extraordinary/good/better/terrible MR (positive/negative) It was [MASK] ! <S1> epic/terrible <S1> It’s [MASK] . epic/awful <S1> A [MASK] piece of work . exquisite/horrible CR (positive/negative) <S1> It’s [MASK] ! fantastic/horrible <S1> The quality is [MASK] . neat/pointless <S1> That is [MASK] . magnificent/unacceptable MPQA (positive/negative) <S1> is [MASK] . important/close <S1>, [MASK] ! needed/bad <S1>. [MASK] . unexpected/shocking Subj (subjective/objective) <S1> It’s all [MASK] . everywhere/tragic <S1> It’s [MASK] . everywhere/horrifying <S1> Is it [MASK] ? something/surreal TREC (abbreviation/entity/description/human/location/numeric) Q: [MASK] : <S1> Application/Advisor/Discussion/Culture/Assignment/Minute <S1> Why [MASK]? Production/AE/Context/Artist/Assignment/Minute <S1> Answer: [MASK] . Personality/Advisor/Conclusion/Hum/Assignment/Minute CoLA (grammatical/not grammatical) <S1> You are [MASK] . one/proof It is [MASK] . <S1> wrong/sad I am [MASK] . <S1> misleading/disappointing MNLI (entailment/neutral/contradiction) <S1> . [MASK] , you are right , <S2> Fine/Plus/Otherwise <S1> . [MASK] you’re right <S2> There/Plus/Otherwise <S1> . [MASK] ! <S2> Meaning/Plus/Otherwise SNLI (entailment/neutral/contradiction) <S1> . [MASK] , no , <S2> Alright/Watch/Except <S1> . [MASK] , in this case <S2> Hi/Watch/Worse <S1> . [MASK] this time <S2> Regardless/Fortunately/Unless QNLI (entailment/not entailment) <S1> ? [MASK] . Yes , <S2> Okay/Nonetheless <S1> ? [MASK] . It is known that <S2> Notably/Yet <S1> ? [MASK] , however , <S2> Specifically/Notably RTE (entailment/not entailment) <S1> . [MASK] , I believe <S2> Clearly/Yet <S1> . [MASK] , I think that <S2> Accordingly/meanwhile <S1> . [MASK] , I think <S2> So/Meanwhile MRPC (equivalent/not equivalent) <S1> . [MASK] ! <S2> Rather/Alas <S1> . [MASK] . This is the first time <S2> At/Thus <S1> . [MASK] . That’s right . <S2> Instead/Moreover QQP (equivalent/not equivalent) <S1> ? [MASK] , but <S2> Me/Since <S1> ? [MASK] , please , <S2> Um/Best <S1> ? [MASK] , I want to know <S2> Ironically/Beyond STS-B (yu/yl) <S1> . [MASK] sir <S2> Note/Next <S1> . [MASK] , it is not . <S2> Yesterday/meanwhile <S1> . [MASK] . It is <S2> Yeah/meanwhile\nTable E.1: Top 3 automatically generated templates and label words for all tasks based on one split of K = 16 training examples. Note that automatic template results are based on manual label words and automatic label word results are based on manual templates provided in Table 1."
    } ],
    "references" : [ {
      "title" : "Learning to few-shot learn across diverse natural language classification tasks",
      "author" : [ "Trapit Bansal", "Rishikesh Jha", "Andrew McCallum." ],
      "venue" : "International Conference on Computational Linguistics (COLING).",
      "citeRegEx" : "Bansal et al\\.,? 2020a",
      "shortCiteRegEx" : "Bansal et al\\.",
      "year" : 2020
    }, {
      "title" : "Self-supervised meta-learning for few-shot natural language classification tasks",
      "author" : [ "Trapit Bansal", "Rishikesh Jha", "Tsendsuren Munkhdalai", "Andrew McCallum." ],
      "venue" : "Empirical Methods in Natural Language Processing (EMNLP).",
      "citeRegEx" : "Bansal et al\\.,? 2020b",
      "shortCiteRegEx" : "Bansal et al\\.",
      "year" : 2020
    }, {
      "title" : "Few-shot text classification with distributional signatures",
      "author" : [ "Yujia Bao", "Menghua Wu", "Shiyu Chang", "Regina Barzilay." ],
      "venue" : "International Conference on Learning Representations (ICLR).",
      "citeRegEx" : "Bao et al\\.,? 2020",
      "shortCiteRegEx" : "Bao et al\\.",
      "year" : 2020
    }, {
      "title" : "The second PASCAL recognising textual entailment challenge",
      "author" : [ "Roy Bar Haim", "Ido Dagan", "Bill Dolan", "Lisa Ferro", "Danilo Giampiccolo", "Bernardo Magnini", "Idan Szpektor" ],
      "venue" : null,
      "citeRegEx" : "Haim et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Haim et al\\.",
      "year" : 2006
    }, {
      "title" : "Longformer: The long-document Transformer",
      "author" : [ "Iz Beltagy", "Matthew E. Peters", "Arman Cohan." ],
      "venue" : "arXiv:2004.05150.",
      "citeRegEx" : "Beltagy et al\\.,? 2020",
      "shortCiteRegEx" : "Beltagy et al\\.",
      "year" : 2020
    }, {
      "title" : "The fifth PASCAL recognizing textual entailment challenge",
      "author" : [ "Luisa Bentivogli", "Peter Clark", "Ido Dagan", "Danilo Giampiccolo." ],
      "venue" : "TAC.",
      "citeRegEx" : "Bentivogli et al\\.,? 2009",
      "shortCiteRegEx" : "Bentivogli et al\\.",
      "year" : 2009
    }, {
      "title" : "A large annotated corpus for learning natural language inference",
      "author" : [ "Samuel Bowman", "Gabor Angeli", "Christopher Potts", "Christopher D Manning." ],
      "venue" : "Empirical Methods in Natural Language Processing (EMNLP).",
      "citeRegEx" : "Bowman et al\\.,? 2015",
      "shortCiteRegEx" : "Bowman et al\\.",
      "year" : 2015
    }, {
      "title" : "Language models are few-shot learners",
      "author" : [ "Tom B Brown", "Benjamin Mann", "Nick Ryder", "Melanie Subbiah", "Jared Kaplan", "Prafulla Dhariwal", "Arvind Neelakantan", "Pranav Shyam", "Girish Sastry", "Amanda Askell" ],
      "venue" : null,
      "citeRegEx" : "Brown et al\\.,? \\Q2020\\E",
      "shortCiteRegEx" : "Brown et al\\.",
      "year" : 2020
    }, {
      "title" : "SemEval-2017 task 1: Semantic textual similarity multilingual and crosslingual focused evaluation",
      "author" : [ "Daniel Cer", "Mona Diab", "Eneko Agirre", "Iñigo LopezGazpio", "Lucia Specia." ],
      "venue" : "the 11th International Workshop on Semantic Evaluation (SemEval-",
      "citeRegEx" : "Cer et al\\.,? 2017",
      "shortCiteRegEx" : "Cer et al\\.",
      "year" : 2017
    }, {
      "title" : "MixText: Linguistically-informed interpolation of hidden space for semi-supervised text classification",
      "author" : [ "Jiaao Chen", "Zichao Yang", "Diyi Yang." ],
      "venue" : "Association for Computational Linguistics (ACL).",
      "citeRegEx" : "Chen et al\\.,? 2020",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2020
    }, {
      "title" : "The PASCAL recognising textual entailment challenge",
      "author" : [ "Ido Dagan", "Oren Glickman", "Bernardo Magnini." ],
      "venue" : "the First International Conference on Machine Learning Challenges: Evaluating Predictive Uncertainty Visual Object Classification, and",
      "citeRegEx" : "Dagan et al\\.,? 2005",
      "shortCiteRegEx" : "Dagan et al\\.",
      "year" : 2005
    }, {
      "title" : "Commonsense knowledge mining from pretrained models",
      "author" : [ "Joe Davison", "Joshua Feldman", "Alexander M Rush." ],
      "venue" : "Empirical Methods in Natural Language Processing (EMNLP).",
      "citeRegEx" : "Davison et al\\.,? 2019",
      "shortCiteRegEx" : "Davison et al\\.",
      "year" : 2019
    }, {
      "title" : "BERT: Pre-training of deep bidirectional Transformers for language understanding",
      "author" : [ "Jacob Devlin", "Ming-Wei Chang", "Kenton Lee", "Kristina Toutanova." ],
      "venue" : "North American Chapter of the Association for Computational Linguistics (NAACL).",
      "citeRegEx" : "Devlin et al\\.,? 2019",
      "shortCiteRegEx" : "Devlin et al\\.",
      "year" : 2019
    }, {
      "title" : "Fine-tuning pretrained language models: Weight initializations, data orders, and early stopping",
      "author" : [ "Jesse Dodge", "Gabriel Ilharco", "Roy Schwartz", "Ali Farhadi", "Hannaneh Hajishirzi", "Noah Smith." ],
      "venue" : "arXiv preprint arXiv:2002.06305.",
      "citeRegEx" : "Dodge et al\\.,? 2020",
      "shortCiteRegEx" : "Dodge et al\\.",
      "year" : 2020
    }, {
      "title" : "Automatically constructing a corpus of sentential paraphrases",
      "author" : [ "William B. Dolan", "Chris Brockett." ],
      "venue" : "the Third International Workshop on Paraphrasing (IWP2005).",
      "citeRegEx" : "Dolan and Brockett.,? 2005",
      "shortCiteRegEx" : "Dolan and Brockett.",
      "year" : 2005
    }, {
      "title" : "The third PASCAL recognizing textual entailment challenge",
      "author" : [ "Danilo Giampiccolo", "Bernardo Magnini", "Ido Dagan", "Bill Dolan." ],
      "venue" : "the ACLPASCAL Workshop on Textual Entailment and Paraphrasing.",
      "citeRegEx" : "Giampiccolo et al\\.,? 2007",
      "shortCiteRegEx" : "Giampiccolo et al\\.",
      "year" : 2007
    }, {
      "title" : "Fewrel: A large-scale supervised few-shot relation classification dataset with state-of-the-art evaluation",
      "author" : [ "Xu Han", "Hao Zhu", "Pengfei Yu", "Ziyun Wang", "Yuan Yao", "Zhiyuan Liu", "Maosong Sun." ],
      "venue" : "Empirical Methods in Natural Language Processing",
      "citeRegEx" : "Han et al\\.,? 2018",
      "shortCiteRegEx" : "Han et al\\.",
      "year" : 2018
    }, {
      "title" : "Universal language model fine-tuning for text classification",
      "author" : [ "Jeremy Howard", "Sebastian Ruder." ],
      "venue" : "Association for Computational Linguistics (ACL).",
      "citeRegEx" : "Howard and Ruder.,? 2018",
      "shortCiteRegEx" : "Howard and Ruder.",
      "year" : 2018
    }, {
      "title" : "Mining and summarizing customer reviews",
      "author" : [ "Minqing Hu", "Bing Liu." ],
      "venue" : "ACM SIGKDD international conference on Knowledge discovery and data mining.",
      "citeRegEx" : "Hu and Liu.,? 2004",
      "shortCiteRegEx" : "Hu and Liu.",
      "year" : 2004
    }, {
      "title" : "How can we know what language models know? Transactions of the Association of Computational Linguistics (TACL)",
      "author" : [ "Zhengbao Jiang", "Frank F Xu", "Jun Araki", "Graham Neubig" ],
      "venue" : null,
      "citeRegEx" : "Jiang et al\\.,? \\Q2020\\E",
      "shortCiteRegEx" : "Jiang et al\\.",
      "year" : 2020
    }, {
      "title" : "Mixout: Effective regularization to finetune large-scale pretrained language models",
      "author" : [ "Cheolhyoung Lee", "Kyunghyun Cho", "Wanmo Kang." ],
      "venue" : "International Conference on Learning Representations (ICLR).",
      "citeRegEx" : "Lee et al\\.,? 2020",
      "shortCiteRegEx" : "Lee et al\\.",
      "year" : 2020
    }, {
      "title" : "RoBERTa: A robustly optimized BERT pretraining approach",
      "author" : [ "Yinhan Liu", "Myle Ott", "Naman Goyal", "Jingfei Du", "Mandar Joshi", "Danqi Chen", "Omer Levy", "Mike Lewis", "Luke Zettlemoyer", "Veselin Stoyanov." ],
      "venue" : "arXiv preprint arXiv:1907.11692.",
      "citeRegEx" : "Liu et al\\.,? 2019",
      "shortCiteRegEx" : "Liu et al\\.",
      "year" : 2019
    }, {
      "title" : "Hyperspherical prototype networks",
      "author" : [ "Pascal Mettes", "Elise van der Pol", "Cees Snoek." ],
      "venue" : "Advances in Neural Information Processing Systems (NeurIPS).",
      "citeRegEx" : "Mettes et al\\.,? 2019",
      "shortCiteRegEx" : "Mettes et al\\.",
      "year" : 2019
    }, {
      "title" : "Adversarial training methods for semisupervised text classification",
      "author" : [ "Takeru Miyato", "Andrew M Dai", "Ian Goodfellow." ],
      "venue" : "International Conference on Learning Representations (ICLR).",
      "citeRegEx" : "Miyato et al\\.,? 2017",
      "shortCiteRegEx" : "Miyato et al\\.",
      "year" : 2017
    }, {
      "title" : "A sentimental education: Sentiment analysis using subjectivity summarization based on minimum cuts",
      "author" : [ "Bo Pang", "Lillian Lee." ],
      "venue" : "Association for Computational Linguistics (ACL).",
      "citeRegEx" : "Pang and Lee.,? 2004",
      "shortCiteRegEx" : "Pang and Lee.",
      "year" : 2004
    }, {
      "title" : "Seeing stars: Exploiting class relationships for sentiment categorization with respect to rating scales",
      "author" : [ "Bo Pang", "Lillian Lee." ],
      "venue" : "Association for Computational Linguistics (ACL).",
      "citeRegEx" : "Pang and Lee.,? 2005",
      "shortCiteRegEx" : "Pang and Lee.",
      "year" : 2005
    }, {
      "title" : "Language models as knowledge bases? In Empirical Methods in Natural Language Processing (EMNLP)",
      "author" : [ "Fabio Petroni", "Tim Rocktäschel", "Sebastian Riedel", "Patrick Lewis", "Anton Bakhtin", "Yuxiang Wu", "Alexander Miller" ],
      "venue" : null,
      "citeRegEx" : "Petroni et al\\.,? \\Q2019\\E",
      "shortCiteRegEx" : "Petroni et al\\.",
      "year" : 2019
    }, {
      "title" : "Sentence encoders on STILTs: Supplementary training on intermediate labeled-data tasks",
      "author" : [ "Jason Phang", "Thibault Févry", "Samuel R Bowman." ],
      "venue" : "arXiv preprint arXiv:1811.01088.",
      "citeRegEx" : "Phang et al\\.,? 2018",
      "shortCiteRegEx" : "Phang et al\\.",
      "year" : 2018
    }, {
      "title" : "Improving language understanding by generative pre-training",
      "author" : [ "Alec Radford", "Karthik Narasimhan", "Tim Salimans", "Ilya Sutskever." ],
      "venue" : "Technical report, OpenAI.",
      "citeRegEx" : "Radford et al\\.,? 2018",
      "shortCiteRegEx" : "Radford et al\\.",
      "year" : 2018
    }, {
      "title" : "Language models are unsupervised multitask learners",
      "author" : [ "Alec Radford", "Jeff Wu", "Rewon Child", "David Luan", "Dario Amodei", "Ilya Sutskever." ],
      "venue" : "Technical report, OpenAI.",
      "citeRegEx" : "Radford et al\\.,? 2019",
      "shortCiteRegEx" : "Radford et al\\.",
      "year" : 2019
    }, {
      "title" : "Exploring the limits of transfer learning with a unified text-to-text Transformer",
      "author" : [ "Colin Raffel", "Noam Shazeer", "Adam Roberts", "Katherine Lee", "Sharan Narang", "Michael Matena", "Yanqi Zhou", "Wei Li", "Peter J Liu." ],
      "venue" : "The Journal of Machine Learning Research",
      "citeRegEx" : "Raffel et al\\.,? 2020",
      "shortCiteRegEx" : "Raffel et al\\.",
      "year" : 2020
    }, {
      "title" : "SQuAD: 100,000+ questions for machine comprehension of text",
      "author" : [ "Pranav Rajpurkar", "Jian Zhang", "Konstantin Lopyrev", "Percy Liang." ],
      "venue" : "Empirical Methods in Natural Language Processing (EMNLP).",
      "citeRegEx" : "Rajpurkar et al\\.,? 2016",
      "shortCiteRegEx" : "Rajpurkar et al\\.",
      "year" : 2016
    }, {
      "title" : "SentenceBERT: Sentence embeddings using Siamese BERTnetworks",
      "author" : [ "Nils Reimers", "Iryna Gurevych." ],
      "venue" : "Empirical Methods in Natural Language Processing and International Joint Conference on Natural Language Processing (EMNLP-",
      "citeRegEx" : "Reimers and Gurevych.,? 2019",
      "shortCiteRegEx" : "Reimers and Gurevych.",
      "year" : 2019
    }, {
      "title" : "Automatically identifying words that can serve as labels for few-shot text classification",
      "author" : [ "Timo Schick", "Helmut Schmid", "Hinrich Schütze." ],
      "venue" : "International Conference on Computational Linguistics (COLING).",
      "citeRegEx" : "Schick et al\\.,? 2020",
      "shortCiteRegEx" : "Schick et al\\.",
      "year" : 2020
    }, {
      "title" : "Exploiting cloze questions for few-shot text classification and natural language inference",
      "author" : [ "Timo Schick", "Hinrich Schütze." ],
      "venue" : "European Chapter of the Association for Computational Linguistics (EACL).",
      "citeRegEx" : "Schick and Schütze.,? 2021a",
      "shortCiteRegEx" : "Schick and Schütze.",
      "year" : 2021
    }, {
      "title" : "It’s not just size that matters: Small language models are also few-shot learners",
      "author" : [ "Timo Schick", "Hinrich Schütze." ],
      "venue" : "North American Chapter of the Association for Computational Linguistics (NAACL).",
      "citeRegEx" : "Schick and Schütze.,? 2021b",
      "shortCiteRegEx" : "Schick and Schütze.",
      "year" : 2021
    }, {
      "title" : "AutoPrompt: Automatic prompt construction for masked language models",
      "author" : [ "Taylor Shin", "Yasaman Razeghi", "Robert L. Logan IV", "Eric Wallace", "Sameer Singh." ],
      "venue" : "Empirical Methods in Natural Language Processing (EMNLP).",
      "citeRegEx" : "Shin et al\\.,? 2020",
      "shortCiteRegEx" : "Shin et al\\.",
      "year" : 2020
    }, {
      "title" : "Recursive deep models for semantic compositionality over a sentiment treebank",
      "author" : [ "Richard Socher", "Alex Perelygin", "Jean Wu", "Jason Chuang", "Christopher D. Manning", "Andrew Ng", "Christopher Potts." ],
      "venue" : "Empirical Methods in Natural Language",
      "citeRegEx" : "Socher et al\\.,? 2013",
      "shortCiteRegEx" : "Socher et al\\.",
      "year" : 2013
    }, {
      "title" : "oLMpics-on what language model pre-training captures",
      "author" : [ "Alon Talmor", "Yanai Elazar", "Yoav Goldberg", "Jonathan Berant." ],
      "venue" : "Transactions of the Association of Computational Linguistics (TACL), 8.",
      "citeRegEx" : "Talmor et al\\.,? 2020",
      "shortCiteRegEx" : "Talmor et al\\.",
      "year" : 2020
    }, {
      "title" : "A simple method for commonsense reasoning",
      "author" : [ "Trieu H Trinh", "Quoc V Le." ],
      "venue" : "arXiv preprint arXiv:1806.02847.",
      "citeRegEx" : "Trinh and Le.,? 2018",
      "shortCiteRegEx" : "Trinh and Le.",
      "year" : 2018
    }, {
      "title" : "Building a question answering test collection",
      "author" : [ "Ellen M Voorhees", "Dawn M Tice." ],
      "venue" : "the 23rd annual international ACM SIGIR conference on Research and development in information retrieval.",
      "citeRegEx" : "Voorhees and Tice.,? 2000",
      "shortCiteRegEx" : "Voorhees and Tice.",
      "year" : 2000
    }, {
      "title" : "GLUE: A multi-task benchmark and analysis platform for natural language understanding",
      "author" : [ "Alex Wang", "Amanpreet Singh", "Julian Michael", "Felix Hill", "Omer Levy", "Samuel R Bowman." ],
      "venue" : "International Conference on Learning Representations",
      "citeRegEx" : "Wang et al\\.,? 2019",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2019
    }, {
      "title" : "Neural network acceptability judgments",
      "author" : [ "Alex Warstadt", "Amanpreet Singh", "Samuel R. Bowman." ],
      "venue" : "Transactions of the Association of Computational Linguistics (TACL), 7.",
      "citeRegEx" : "Warstadt et al\\.,? 2019",
      "shortCiteRegEx" : "Warstadt et al\\.",
      "year" : 2019
    }, {
      "title" : "Annotating expressions of opinions and emotions in language",
      "author" : [ "Janyce Wiebe", "Theresa Wilson", "Claire Cardie." ],
      "venue" : "Language resources and evaluation, 39(2-3).",
      "citeRegEx" : "Wiebe et al\\.,? 2005",
      "shortCiteRegEx" : "Wiebe et al\\.",
      "year" : 2005
    }, {
      "title" : "A broad-coverage challenge corpus for sentence understanding through inference",
      "author" : [ "Adina Williams", "Nikita Nangia", "Samuel Bowman." ],
      "venue" : "North American Chapter of the Association for Computational Linguistics: Human Language Technologies",
      "citeRegEx" : "Williams et al\\.,? 2018",
      "shortCiteRegEx" : "Williams et al\\.",
      "year" : 2018
    }, {
      "title" : "Unsupervised data augmentation for consistency training",
      "author" : [ "Qizhe Xie", "Zihang Dai", "Eduard Hovy", "Thang Luong", "Quoc Le." ],
      "venue" : "Advances in Neural Information Processing Systems (NeurIPS), 33.",
      "citeRegEx" : "Xie et al\\.,? 2020",
      "shortCiteRegEx" : "Xie et al\\.",
      "year" : 2020
    }, {
      "title" : "Universal natural language processing with limited annotations: Try few-shot textual entailment as a start",
      "author" : [ "Wenpeng Yin", "Nazneen Fatema Rajani", "Dragomir Radev", "Richard Socher", "Caiming Xiong." ],
      "venue" : "Empirical Methods in Natural Language",
      "citeRegEx" : "Yin et al\\.,? 2020",
      "shortCiteRegEx" : "Yin et al\\.",
      "year" : 2020
    }, {
      "title" : "Diverse few-shot text classification with multiple metrics. In North American Chapter of the Association for Computational Linguistics (NAACL)",
      "author" : [ "Bowen Zhou" ],
      "venue" : null,
      "citeRegEx" : "Zhou.,? \\Q2018\\E",
      "shortCiteRegEx" : "Zhou.",
      "year" : 2018
    }, {
      "title" : "Revisiting fewsample BERT fine-tuning",
      "author" : [ "Tianyi Zhang", "Felix Wu", "Arzoo Katiyar", "Kilian Q Weinberger", "Yoav Artzi." ],
      "venue" : "International Conference on Learning Representations (ICLR).",
      "citeRegEx" : "Zhang et al\\.,? 2021",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2021
    }, {
      "title" : "Factual probing is [MASK]: Learning vs",
      "author" : [ "Zexuan Zhong", "Dan Friedman", "Danqi Chen." ],
      "venue" : "learning to recall. In North American Association for Computational Linguistics (NAACL).",
      "citeRegEx" : "Zhong et al\\.,? 2021",
      "shortCiteRegEx" : "Zhong et al\\.",
      "year" : 2021
    }, {
      "title" : "QQP12 and STS-B (Cer et al., 2017)",
      "author" : [ "Bar Haim" ],
      "venue" : "Giampiccolo et al.,",
      "citeRegEx" : "Haim,? \\Q2006\\E",
      "shortCiteRegEx" : "Haim",
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "The recent GPT-3 model (Brown et al., 2020) achieves remarkable few-shot performance solely by leveraging a natural-language prompt and a few task demonstrations as input context.",
      "startOffset" : 23,
      "endOffset" : 43
    }, {
      "referenceID" : 7,
      "context" : "The GPT-3 model (Brown et al., 2020) has made waves in the NLP community by demonstrating astounding few-shot capabilities on myriad language understanding tasks.",
      "startOffset" : 16,
      "endOffset" : 36
    }, {
      "referenceID" : 12,
      "context" : "In this work, we study a more practical scenario in which we only assume access to a moderatelysized language model such as BERT (Devlin et al., 2019) or RoBERTa (Liu et al.",
      "startOffset" : 129,
      "endOffset" : 150
    }, {
      "referenceID" : 21,
      "context" : ", 2019) or RoBERTa (Liu et al., 2019), and a small number of examples (i.",
      "startOffset" : 19,
      "endOffset" : 37
    }, {
      "referenceID" : 7,
      "context" : "First, we follow the route of prompt-based prediction, first developed by the GPT series (Radford et al., 2018, 2019; Brown et al., 2020) for zero-shot prediction and recently studied by PET (Schick and Schütze, 2021a,b) for fine-tuning.",
      "startOffset" : 89,
      "endOffset" : 137
    }, {
      "referenceID" : 30,
      "context" : "We address this issue by introducing automatic prompt generation, including a pruned brute-force search to identify the best working label words, and a novel decoding objective to automatically generate templates using the generative T5 model (Raffel et al., 2020)—all of which only require the few-shot training data.",
      "startOffset" : 243,
      "endOffset" : 264
    }, {
      "referenceID" : 7,
      "context" : "The GPT series (Radford et al., 2018, 2019; Brown et al., 2020) fueled the development of prompt-based learning, and we follow many of its core concepts.",
      "startOffset" : 15,
      "endOffset" : 63
    }, {
      "referenceID" : 19,
      "context" : "3818 erate in limited domains, such as finding patterns to express specific relations (Jiang et al., 2020), or require a large number of examples for gradientguided search (Shin et al.",
      "startOffset" : 86,
      "endOffset" : 106
    }, {
      "referenceID" : 36,
      "context" : ", 2020), or require a large number of examples for gradientguided search (Shin et al., 2020; Zhong et al., 2021).",
      "startOffset" : 73,
      "endOffset" : 112
    }, {
      "referenceID" : 49,
      "context" : ", 2020), or require a large number of examples for gradientguided search (Shin et al., 2020; Zhong et al., 2021).",
      "startOffset" : 73,
      "endOffset" : 112
    }, {
      "referenceID" : 17,
      "context" : "A number of recent studies have focused on better methods for fine-tuning language models (Howard and Ruder, 2018; Dodge et al., 2020; Lee et al., 2020; Zhang et al., 2021).",
      "startOffset" : 90,
      "endOffset" : 172
    }, {
      "referenceID" : 13,
      "context" : "A number of recent studies have focused on better methods for fine-tuning language models (Howard and Ruder, 2018; Dodge et al., 2020; Lee et al., 2020; Zhang et al., 2021).",
      "startOffset" : 90,
      "endOffset" : 172
    }, {
      "referenceID" : 20,
      "context" : "A number of recent studies have focused on better methods for fine-tuning language models (Howard and Ruder, 2018; Dodge et al., 2020; Lee et al., 2020; Zhang et al., 2021).",
      "startOffset" : 90,
      "endOffset" : 172
    }, {
      "referenceID" : 48,
      "context" : "A number of recent studies have focused on better methods for fine-tuning language models (Howard and Ruder, 2018; Dodge et al., 2020; Lee et al., 2020; Zhang et al., 2021).",
      "startOffset" : 90,
      "endOffset" : 172
    }, {
      "referenceID" : 23,
      "context" : "learning (Miyato et al., 2017; Xie et al., 2020; Chen et al., 2020), where a set of unlabeled examples are given; (2) meta-learning (Yu et al.",
      "startOffset" : 9,
      "endOffset" : 67
    }, {
      "referenceID" : 45,
      "context" : "learning (Miyato et al., 2017; Xie et al., 2020; Chen et al., 2020), where a set of unlabeled examples are given; (2) meta-learning (Yu et al.",
      "startOffset" : 9,
      "endOffset" : 67
    }, {
      "referenceID" : 9,
      "context" : "learning (Miyato et al., 2017; Xie et al., 2020; Chen et al., 2020), where a set of unlabeled examples are given; (2) meta-learning (Yu et al.",
      "startOffset" : 9,
      "endOffset" : 67
    }, {
      "referenceID" : 16,
      "context" : ", 2020), where a set of unlabeled examples are given; (2) meta-learning (Yu et al., 2018; Han et al., 2018; Bansal et al., 2020a,b; Bao et al., 2020), where a set of auxiliary tasks are given; and (3) in-",
      "startOffset" : 72,
      "endOffset" : 149
    }, {
      "referenceID" : 2,
      "context" : ", 2020), where a set of unlabeled examples are given; (2) meta-learning (Yu et al., 2018; Han et al., 2018; Bansal et al., 2020a,b; Bao et al., 2020), where a set of auxiliary tasks are given; and (3) in-",
      "startOffset" : 72,
      "endOffset" : 149
    }, {
      "referenceID" : 27,
      "context" : "termediate training (Phang et al., 2018; Yin et al., 2020), where a related, intermediate task is given.",
      "startOffset" : 20,
      "endOffset" : 58
    }, {
      "referenceID" : 46,
      "context" : "termediate training (Phang et al., 2018; Yin et al., 2020), where a related, intermediate task is given.",
      "startOffset" : 20,
      "endOffset" : 58
    }, {
      "referenceID" : 41,
      "context" : "We conduct a systematic study across 8 single-sentence and 7 sentence-pair English tasks, including 8 tasks from the GLUE benchmark (Wang et al., 2019), SNLI (Bowman et al.",
      "startOffset" : 132,
      "endOffset" : 151
    }, {
      "referenceID" : 6,
      "context" : ", 2019), SNLI (Bowman et al., 2015), and 6 other popular sentence classification tasks (SST-5, MR, CR, MPQA, Subj, TREC).",
      "startOffset" : 14,
      "endOffset" : 35
    }, {
      "referenceID" : 13,
      "context" : "from instability (Dodge et al., 2020; Zhang et al., 2021), and results may change dramatically given a new split of data.",
      "startOffset" : 17,
      "endOffset" : 57
    }, {
      "referenceID" : 48,
      "context" : "from instability (Dodge et al., 2020; Zhang et al., 2021), and results may change dramatically given a new split of data.",
      "startOffset" : 17,
      "endOffset" : 57
    }, {
      "referenceID" : 30,
      "context" : "To address this challenging problem, we propose to use T5 (Raffel et al., 2020),",
      "startOffset" : 58,
      "endOffset" : 79
    }, {
      "referenceID" : 32,
      "context" : "Specifically, we use a pre-trained SBERT (Reimers and Gurevych, 2019) model to obtain embeddings for all input sentences (for sentence-pair tasks, we use the concatenation",
      "startOffset" : 41,
      "endOffset" : 69
    } ],
    "year" : 2021,
    "abstractText" : "The recent GPT-3 model (Brown et al., 2020) achieves remarkable few-shot performance solely by leveraging a natural-language prompt and a few task demonstrations as input context. Inspired by their findings, we study few-shot learning in a more practical scenario, where we use smaller language models for which fine-tuning is computationally efficient. We present LM-BFF—better few-shot fine-tuning of language models1—a suite of simple and complementary techniques for finetuning language models on a small number of annotated examples. Our approach includes (1) prompt-based fine-tuning together with a novel pipeline for automating prompt generation; and (2) a refined strategy for dynamically and selectively incorporating demonstrations into each context. Finally, we present a systematic evaluation for analyzing few-shot performance on a range of NLP tasks, including classification and regression. Our experiments demonstrate that our methods combine to dramatically outperform standard fine-tuning procedures in this low resource setting, achieving up to 30% absolute improvement, and 11% on average across all tasks. Our approach makes minimal assumptions on task resources and domain expertise, and hence constitutes a strong task-agnostic method for few-shot learning.2",
    "creator" : "LaTeX with hyperref"
  }
}
optimizing deeper transformers on small datasets.
peng xu1, dhruv kumar∗1,2, wei yang1, wenjie zi1, keyi tang1, chenyang huang∗1,5,jackie chi kit cheung1,3,4, simon j.d.
prince1, yanshuai cao11borealis ai 2university of waterloo3mcgill university 4canada cifar chair, mila 5university of alberta{peng.z.xu, wei.yang, wenjie.zi, keyi.tang, simon.prince, yanshuai.cao}@borealisai.com.
dhruv.kumar@uwaterloo.ca, chuang8@ualberta.ca, jcheung@cs.mcgill.ca.
abstract.
it is a common belief that training deep trans-formers from scratch requires large datasets.
consequently, for small datasets, people usu-ally use shallow and simple additional lay-ers on top of pre-trained models during ﬁne-tuning.
this work shows that this does not al-ways need to be the case: with proper initial-ization and optimization, the beneﬁts of verydeep transformers can carry over to challeng-ing tasks with small datasets, including text-to-sql semantic parsing and logical readingin particular, we success-comprehension.
fully train 48 layers of transformers, com-prising 24 ﬁne-tuned layers from pre-trainedroberta and 24 relation-aware layers trainedfrom scratch.
with fewer training steps andno task-speciﬁc pre-training, we obtain thestate-of-the-art performance on the challeng-ing cross-domain text-to-sql parsing bench-mark spider1.
we achieve this by derivinga novel data-dependent transformer fixed-update initialization scheme (dt-fixup), in-spired by the prior t-fixup work (huang et al.,2020).
further error analysis shows that in-creasing depth can help improve generaliza-tion on small datasets for hard cases that re-quire reasoning and structural understanding..1.introduction.
in recent years, large-scale pre-trained languagemodels (radford et al., 2019; devlin et al.,2018; liu et al., 2019b) trained with transform-ers (vaswani et al., 2017) have become standardbuilding blocks of modern nlp systems to helpimprove generalization when task-speciﬁc annota-tions are limited.
in practice, it has been foundthat deeper transformers generally yield better re-sults with sufﬁcient training data (lan et al., 2019),.
∗work done while the author was an intern in borealis ai.
1the code to reproduce our results can be found in:.
https://github.com/borealisai/dt-fixup.
especially on tasks involving reasoning and struc-tural understanding.
this suggests that additionaltransformer layers should be employed in conjunc-tion with pre-trained models, instead of simple andshallow neural components, such as a classiﬁerhead, currently used by models of many nlp tasks.
however, the common belief in the literature is thattraining deep transformers from scratch requireslarge datasets, and few attempts have been made onsmall datasets, to the best of our knowledge.
oneimplication is that although extra transformer lay-ers on top of pre-trained models should help withmore challenging problems in principle, it doesnot work in practice due to limited training data.
we show that after resolving several optimizationissues with the method proposed in this work, itis possible to train very deep transformers withimproved generalization even on small datasets..one advantage of pre-trained models is the re-duced computational resources needed when ﬁne-tuning on small datasets.
for instance, it allowspractitioners to ﬁnetune on a single gpu and obtainstrong performance on a downstream task.
how-ever, the large size of pre-trained models limits thebatch size that can be used in training new trans-former layers on a small computational budget.
de-spite their broad applications, training transformermodels is known to be difﬁcult (popel and bojar,2018).
the standard transformer training approachleverages learning rate warm-up, layer normaliza-tion (ba et al., 2016) and a large batch size, andmodels typically fail to learn when missing anyone of these components.
the restricted batch sizeaggravates the training difﬁculties.
even if a largebatch size can be feasibly employed, poorer gener-alization results are often observed (keskar et al.,2016), especially when the dataset size is only sev-eral times larger than the batch size.
furthermore,many recent works noticed a performance gap inthis training approach due to layer normalization.
proceedingsofthe59thannualmeetingoftheassociationforcomputationallinguisticsandthe11thinternationaljointconferenceonnaturallanguageprocessing,pages2089–2102august1–6,2021.©2021associationforcomputationallinguistics2089(xu et al., 2019; nguyen and salazar, 2019; zhanget al., 2019a; wang et al., 2019b; liu et al., 2020;huang et al., 2020)..inspired by the recent t-fixup by huang et al.
(2020), which eliminates the need for learning ratewarm-up and layer normalization to train vanillatransformers, we derive a data-dependent initial-ization strategy by applying different analyses toaddress several key limitations of t-fixup.
wecall our method the data-dependent transformerfixed-update initialization scheme, dt-fixup.
inthe mixed setup of additional yet-to-be-trainedtransformers on top of pre-trained models, dt-fixup enables the training of signiﬁcantly deepertransformers, and is generally applicable to differ-ent neural architectures.
our derivation also ex-tends beyond vanilla transformers to transformerswith relational encodings (shaw et al., 2018), al-lowing us to apply the results to one variant calledrelation-aware transformer (wang et al., 2019a).
by applying dt-fixup on different tasks, we showthat the impression that deep transformers do notwork on small datasets stems from the optimizationprocedure rather than the architecture.
with properinitialization and optimization, training extra trans-former layers is shown to facilitate the learning ofcomplex relations and structures in the data..we verify the effectiveness of dt-fixup on spi-der (yu et al., 2018), a complex and cross-domaintext-to-sql semantic parsing benchmark, andrecolr (yu et al., 2020b), a reading comprehensiondataset requiring logical reasoning.
while text-to-sql semantic parsing is inherently different fromreading comprehension, they share similar charac-teristics which require certain levels of reasoningand structural understanding ability.
meanwhile,the sizes of both datasets are less than 10k trainingsamples, which is tiny by deep learning standardsand renders large-batch training undesirable due topoor generalization2..on both datasets, dt-fixup consistently out-performs the standard approach with better gen-eralization and allows the training of signiﬁcantlydeeper transformer models.
for spider, we suc-cessfully apply dt-fixup to train a text-to-sqlparser containing 48 transformer layers, with 24relation-aware layers trained from scratch on topof 24 pre-trained layers from pre-trained roberta.
2for a comparison, t-fixup applies batch sizes of morethan 1k on machine translation to stabilize the training, whichwould hurt the generalization signiﬁcantly on our datasetswhose sizes are less than 10k..(liu et al., 2019b).
our parser achieves 70.9% ex-act match accuracy on the spider test set, whichis the state of the art at the time of writing.
at thesame time, it requires less training steps and notask-speciﬁc pre-training as compared to the priorart (yu et al., 2020a).
for reclor, we rank thesecond on the public leaderboard by simply adding4 transformer layers on top of roberta.
furthererror analysis shows that the performance improve-ments by increasing the depth mainly come frombetter generalization on the harder cases requiringreasoning and structural understanding.
even thefailed predictions from the deep models are morereasonable than from the shallow ones..2 background.
in this section, we present the necessary back-ground by ﬁrst introducing the relation-aware trans-former layer, which outperforms the vanilla trans-former layer with limited data by injecting addi-tional inductive bias (wang et al., 2019a).
then,we introduce the t-fixup technique (huang et al.,2020) for optimizing deeper vanilla transformersand discuss why it does not directly apply in themixed transformer optimization setup..2.1 relative position and relationalencodings in transformers.
consider a set of inputs x = [xxx1, .
.
.
, xxxn] wherexxxi ∈ rdx.
a transformer, introduced by vaswaniet al.
(2017), is a stack of blocks, with each blockconsisting of a multi-head self-attention layer, layernormalizations, a multi-layer perceptron and skipconnections.
each block (with one head in self-attention for notational simplicity) transforms eachxxxi into yyyi ∈ rdx as follows:.
(cid:17).
(cid:16)xxxiqqq(xxxjkkk)(cid:62)(cid:46)(cid:112)dz.
αij = softmaxzzzi = (cid:80)nj=1αijxxxjvvv;˜y˜y˜yi = layernorm(xxxi + zzziwww(cid:62))yyyi = layernorm(˜y˜y˜yi + mlp(˜y˜y˜yi)).
(1).
(2).
(3).
(4).
where the softmax operation is applied across theindex j, mlp is a two-layer perceptron, layer-norm is a layer normalization (ba et al., 2016)layer, and qqq, kkk, vvv ∈ rdx×dz , www ∈ rdx×dz ..in order to bias the transformer toward somepre-existing relational features between the inputs,shaw et al.
(2018) described a way to represent rel-ative position information in a self-attention layer.
2090by changing equation 1-2 as follows:(cid:32)xxxiqqq(xxxjkkk + rrrk√.
αij = softmax.
(cid:33).
ij)(cid:62).
dz.
(5).
zzzi = (cid:80)n.j=1αij(xxxjvvv + rrrvij)here the rrrij ∈ rdz terms encode the known re-lationship between two elements xxxi and xxxj in theinput.
wang et al.
(2019a) adapted this frameworkto effectively encode the schema information usingrrrij’s for text-to-sql parsers, and called it relation-aware transformer (rat)..2.2 t-fixup and its limitations.
huang et al.
(2020) found that the requirementfor the warmup during the early stage training ofthe transformers comes from a combined effectof high variance in the adam optimizer and back-propagation through layer normalization.
bound-ing the gradient updates would reduce the varianceand make training stable, which can be achievedby appropriately initializing the model weights..they derived a weight initialization schemecalled t-fixup for the vanilla transformer that fullyeliminates the need for layer normalization andlearning rate warmup, and stabilizes the trainingto avoid harmful plateaus of poor generalization.
t-fixup requires the inputs xxx to be gaussian ran-domly initialized embeddings with variance d− 12where d is the embedding dimension.
then, theinput and parameters of the encoder, xxx, vvv, www in thevanilla self-attention blocks as well as the weightmatrices in the mlp blocks deﬁned in eq.
1-4 arere-scaled by multiplying with a factor of 0.67n − 14 ,where n are the number of transformer layers..however, there are two restrictions of t-fixupnarrowing down the range of its application.
first,t-fixup is only designed for vanilla transformerbut not other variants like the relative position orrelation-aware version described previously.
sec-ond, they make the critical assumption that theinputs xxx can be freely initialized then scaled tothe same magnitude as vvv, www and mlp weights.
this renders the method inapplicable for the mixedsetup where the inputs to the yet-to-be-trained trans-former layers depend on the outputs from the pre-trained models.
the ﬁrst issue can be addressed byre-deriving the scaling factor following the method-ology of t-fixup but taking into account the addi-tional relational term.
however, to lift the secondrestriction requires changing the assumption andmore dramatic modiﬁcation to the analysis..figure 1: illustration of the general neural architectureon which our method can be applied..3 our approach.
we now follow the analysis framework of t-fixup(huang et al., 2020), but derive the conditions tobound the gradient updates of the self-attentionblock in the presence of a pre-trained model.
basedon the derivation, we propose a data-dependentinitialization strategy for the mixed setup of thenew transformers on pre-trained encodings..3.1 applicable architectures.
our analysis applies to the general architecturetype illustrated in figure 1, where the input passesthrough a pre-transformer, a main transformer, anda post-transformer module before outputting.
thepre and post transformer modules can be any ar-chitectures that can be stably trained with adam(kingma and ba, 2014), including mlp, lstm,cnn, or a pre-trained deep transformer modulewhich can be stably ﬁne-tuned with a learning ratesigniﬁcantly smaller than the main learning rateused for the main transformer module.
for thiswork, we will just consider the case of the maintransformer containing only the encoder for sim-plicity, while our decoder will be an lstm whichcan be viewed as part of the post-transformer mod-ule.
extending our analysis to include deep trans-former decoder is straightforward following theframework of huang et al.
(2020)..we use fe to denote the pre-transformer mod-.
2091ule (e for pre-trained encoder), and its parametersθθθe; similarly fo for post-transformer module (o foroutput) with parameters θθθo.
the main transformermodule fg is a stack of l transformer blocks, eachconsisting of a self-attention block and a mlpblock.
let gl, l = 1, .
.
.
, 2n denote individualself-attention or mlp layers in the blocks (gl’s donot include the skip connections), with parametersθθθl and let l = 2n , fg’s parameters are denoted.
by θθθg =.
θθθl..l(cid:83)l=1.
3.2 theoretical results for stable update.
let the whole model with the output softmaxlayer(s) and all layer normalization blocks removedbe denoted by f (·; θθθ) and the loss function by l,where θθθ are all the learnable parameters.
follow-ing huang et al.
(2020), we aim to derive a condi-tion under which, per each sgd update with learn-ing rate η, the model output changes by θ(η), i.e.
(cid:107)∆f (cid:107) = θ(η) where ∆f = f (·; θθθ−η ∂l)−f (·; θθθ).
∂θθθby taylor expansion, the sgd update is:.
∆f =.
∆θθθo +.
∂f∂f∂f∂θθθo∂θθθe∂θθθgo((cid:107)θθθo(cid:107)2 + (cid:107)θθθg(cid:107)2 + (cid:107)θθθe(cid:107)2).
∆θθθg +.
∆θθθe+.
= − η(.
∂fo∂θθθo∂fg∂θθθg∂fe∂θθθe.
∂fo∂θθθo∂fg∂fo∂θθθg∂fg∂fg∂fo∂fg∂fe+ o(η2).
+.
(cid:62).
(cid:62) ∂l∂fo(cid:62) ∂fo∂fg.
(cid:62) ∂l∂fo.
(cid:62).
+.
∂fe∂θθθe.
(cid:62) ∂fg∂fe.
(cid:62) ∂fo∂fg.
(cid:62) ∂l∂fo.
(cid:62).
).
(6).
(cid:107) = (cid:107) ∂fg∂fe.
(cid:107) = (cid:107) ∂fo∂fg.
(cid:107) = (cid:107) ∂fo∂θθθo.
(cid:107) = θ(1), we only.
as assumed in sec.
3.1, we can stably train fe(cid:107) =.
and fo coupled with l, i.e, (cid:107) ∂l∂fo(cid:107) ∂fe∂θθθeneed to bound the magnitudes of ∂fgto bound∂θθθgthe overall sgd update.
since what we careis the magnitude of the update as it relates tothe depth, we can assume all parameters to bescalars, i.e, qqql, kkkl, vvvl, wwwl, rrrkl reduce to scalarsl ∈ r. the next theorem statesql, kl, vl, wl, rkl , rvthe condition under which, (cid:107) ∂fg(cid:107) is bounded by∂θθθgθ(1), achieving the overall (cid:107)∆f (cid:107) = θ(η)..l , rrrv.
theorem 3.1 assuming (cid:107)xxx(cid:107) = θ(µ) for someµ (cid:29) 1, then (cid:107) ∂fg(cid:107) = θ(1) if (cid:107)vl(cid:107) = (cid:107)wl(cid:107) =∂θθθg.
(cid:16)l (cid:107) = θ.
((4µ2 + 2µ + 2)n )− 1(cid:107)rvfor all en-coder layers l in relation-aware transformers; and.
(cid:17).
2.
(cid:107)vl(cid:107) = (cid:107)wl(cid:107) = θvanilla transformers..(cid:16).
(4µ2n )− 1.
2.
(cid:17).
in the case of.
the proof is in appendix a. one important imme-diate observation is that our scaling as the depthn is to the power of −1/2, whereas t-fixup has ascaling with power of −1/4..while this theorem is all we need for derivingour dt-fixup approach, it is not immediately in-tuitive.
so next we inspect what it takes to boundthe change in a individual layer output (cid:107)∆gl(cid:107) toθ(η/l) in each gradient update.
this will shinesome light on the particular form of the expressionsin theorem 3.1:theorem 3.2 let xxxxxxxxxl = [xln] be the inputinto l-th layer, and assume that (cid:107)∂l/∂gl(cid:107) = θ(1),i.e.
the gradient signal from the layers above isbounded, then ∆gl = gl(xxxl − η ∂l) −∂xxxlgl(xxxl; θθθl) satisﬁes (cid:107)∆gl(cid:107) = θ(η/l) when for alli = 1, .
.
.
, n:.
; θθθl − η ∂l∂θθθl.
1, .
.
.
, xl.
i(cid:107)2 + 2(cid:107)vl(cid:107)(cid:107)rv.
2(cid:107)vl(cid:107)2(cid:107)xl+ (cid:107)wl(cid:107)2(1 + 2(cid:107)xl.
l (cid:107)(cid:107)xli(cid:107)2) = θ(1/n ).
i(cid:107) + (cid:107)rv.
l (cid:107)2.
(7).
for relation-aware transformers.
alternatively, inthe case of vannilla transformers:.
(cid:107)vl(cid:107)2(cid:107)xl.
i(cid:107)2 + (cid:107)wl(cid:107)2(cid:107)xl.
i(cid:107)2 = θ(1/l).
(8).
in this case, the proof is straightforward by takingpartial derivatives of gl with respect to each param-eter, and keep the terms with the lowest powers asthey dominate the norm when the scale is smallerthan one.
appendix b gives the detailed proof.
theinsight from this theorem is: if the input xxxl hasthe same norm as xxx, setting parameters vl, wl, rvl tohave the same norm and solve the equations wouldyield the scale factors in theorem 3.1..remark:in t-fixup, the corresponding condi-tion to eq.
8 keeps the term (cid:107)vl(cid:107)2(cid:107)wl(cid:107)2 which isdropped by ours.
it is due to the fact that t-fixupassumes (cid:107)xi(cid:107) can be controlled to be the same scaleas vl and wl, so the lowest power terms (which aredominating the norms here) are the quartic (4thpower) ones.
for us, (cid:107)xxx(cid:107) is treated separately bya constant to be estimated from data, so the lowestpower terms are the quadratic ones in vl, wl, rvl ineq.
7 and 8, and (cid:107)vl(cid:107)2(cid:107)wl(cid:107)2 are dropped.
anotherimportant distinction from t-fixup is that we as-sume the estimated (cid:107)xxx(cid:107) to be much larger than thescale of vl and wl, unlike the case when they arealso controlled to be the same scale.
as we will.
2092see next, these changes imply our proposed methodemploys more aggressive scaling for initializationas compared to t-fixup, and the assumption that(cid:107)xxx(cid:107) has larger scale is satisﬁed naturally..3.3 proposed method: dt-fixup.
unlike previous works (zhang et al., 2019b; huanget al., 2020), appropriate initialization is not enoughto ensure eq.
7 and 8 during the early stage of thetraining.
this is due to the fact that the input xxxoften depends on the pre-trained model weightsinstead of being initialized by ourselves.
empiri-cally, we observe that the input norm (cid:107)xxx(cid:107) are rela-tively stable throughout the training but difﬁcultyto control directly by re-scaling.
based on this ob-servation, we treat (cid:107)xxx(cid:107) as a constant and estimateit by a forward pass on all the training examplesas µ = maxj[(cid:107)xxxj(cid:107)].
we then use this estimated µin the factors of theorem 3.1 to obtain the scalingneeded for initialization.
since parameters of alllayers are initialized to the same scale, we dropindex l for brevity in this section.
in practice, µ ison the order of 10 for pre-trained models, hencev, w and rvi are naturally two orders of magnitudesmaller.
dt-fixup is described as follows:.
• apply xavier initialization (glorot and ben-gio, 2010) on all free parameters exceptloaded weights from the pre-training models;.
• remove the learning rate warm-up and alllayer normalization in the transformer layers,except those in the pre-trained transformer;.
• forward-pass on all the training examples toget the max input norm µ = maxj[(cid:107)xxxj(cid:107)];.
• inside each transformer layer, scale v, w, rvin the attention block and weight matrices inthe mlp block by (n ∗ (4µ2 + 2µ + 2))− 12for relation-aware transformer layer; or scalev, w in the attention block and weight ma-trices in the mlp block by n − 12 /(2µ) forvanilla transformer layer..4 applications.
4.1 text-to-sql semantic parsing.
we ﬁrst apply dt-fixup on the task of cross-domain text-to-sql semantic parsing.
given anunseen schema s for a database during training,our goal is to translate the natural question q tothe target sql t .
the correct prediction depends.
on the interplay between the questions and theschema structures and the generalization over un-seen schemas during inference.
as a result, rea-soning and structural understanding are crucial toperform well on this task, especially for the morechallenging cases.
we denote our baseline modelas sql-sp3 and henceforth..implementation.
for modeling text-to-sqlgeneration, we adopt the encoder-decoder frame-work which can be directly ﬁt into the architectureshown in fig.
1. first, the pre-transformer modulefe is a pre-trained language model which embedsthe inputs q and s into joint representations xxxifor each column, table si ∈ s and question wordqi ∈ q respectively.
the joint representations arepassed into a sequence of n relation-aware trans-former layers.
the post-transformer module fo isa grammar-guided lstm decoder, which uses thetransformer output yyyi to predict the target sql t .
we follow prior arts (wang et al., 2019a; guo et al.,2019; yin and neubig, 2018) to implement sql-sp.
the implementation details and hyperparametersettings are described in appendix c..dataset.
we evaluate sql-sp on spider (yuet al., 2018), a complex and cross-domain text-to-sql semantic parsing benchmark.
the datasetsize is relatively small by deep learning standards,with only 10,181 questions and 5,693 queries cov-ering 200 databases in 138 domains..4.2 logical reading comprehension.
the second task where we apply dt-fixup is multi-choice reading comprehension requiring logicalreasoning.
given a context, a question and four op-tions, the task is to select the right or most suitableanswer.
rather than extracting relevant informa-tion from a long context, this task relies heavily onthe logical reasoning ability of the models..implementation.
on top of the pre-trained en-codings of the input context, question and options,a stack of n vanilla transformer layers are addedbefore the ﬁnal linear layer which gives the pre-dictions.
the implementation details and hyper-paramter settings are described in appendix d.dataset.
we evaluate on reclor (yu et al.,2020b), a newly curated reading comprehensiondataset requiring logical reasoning.
the datasetcontains logical reasoning questions taken from.
3sql semantic parser..2093standardized exams (such as gmat and lsat)that are designed for students who apply for admis-sion to graduate schools.
similar to spider, thisdataset is also small, with only 6,139 questions..5 experiments.
all the experiments in this paper are conductedwith a signle 16gb nvidia p100 gpu..5.1 semantic parsing: spider results.
as the test set of spider is only accessible throughan evaluation server, most of our analyses are per-formed on the development set.
we use the exactmatch accuracy4 on all examples following yu et al.
(2018), which omits evaluation of generated valuesin the sql queries..modelrat-sql v3 + bert (wang et al., 2019a)rat-sql + grappa (yu et al., 2020a)rat-sql + gap (shi et al., 2020)rat-sql + grappa + gp (zhao et al., 2021)sga-sql + gap (anonymous)rat-sql + grappa + adv (anonymous)dt-fixup sql-sp + roberta (ours).
dev69.773.471.872.873.175.575.0.test65.669.669.769.870.170.570.9.table 1: our accuracy on the spider development andtest sets, as compared to the other approaches at the topof the spider leaderboard as of may 27th, 2021..achieves the new state of the art performance.
no-tably, the top four submissions on the previousleaderboard are all occupied by models leveragingrelation-aware transformers and task-speciﬁc pre-training.
table 2 compares our proposed modelswith the publicly available works.
with enoughtraining steps, our baseline model trained with thestandard optimization strategy achieves the samelevel of performance as compared to rat-sql.
however, models trained with standard optimiza-tion strategy obtain much lower performance withthe same epochs6 of training as compared to modelstrained with dt-fixup and require more trainingsteps to achieve the best accuracy.
at the sametime, by adding more relation-aware transformerlayers, further gains can be obtained for modelstrained with dt-fixup, which achieves the state-of-the-art performance without any task-speciﬁcpre-training on additional data sources.
as men-tioned in section 2.2, in the mixed setup, there isno way to apply t-fixup as it was originally pro-posed.
the closest thing to compare is to drop itsconstraints on the inputs, but training then becomeshighly unstable and fails to converge 4 times outof 5 runs.
these results demonstrate the necessityand effectiveness of dt-fixup to improve and ac-celerate the transformer training for text-to-sqlparsers..pretrain.
(cid:88)(cid:88).
modelrat-sql + bertrat-sql + robertarat-sql + grapparat-sql + gapsql-sp + roberta+ more epochs+ dt-fixup+ dt-fixup & more layers+ t-fixup∗ & more layers.
n88888882424.epochs∼ 200∼ 200∼ 100∼ 20060100606060.acc.
69.769.673.471.866.969.273.575.0failed.
modeldevrat-sqlbridge (ensemble)dt-fixup sql-sptestrat-sqlbridge (ensemble)dt-fixup sql-sp.
easy medium.
hard.
extra.
all.
86.489.191.9.
83.085.387.2.
73.671.780.9.
71.373.477.5.
62.162.160.3.
58.359.660.9.
42.951.848.8.
38.440.346.8.
69.771.175.0.
65.667.570.9.table 3: breakdown of spider accuracy by hardness..table 2: comparisons with the models leveraging re-lational transformers on the spider development set.
pretrain here denotes task-speciﬁc pre-training, whichleverges additional data and tasks, and is orthorgonalto our contribution.
not only we converge faster andreach better solution, simply training longer from thesame baseline cannot close the performance gap.
∗wedrop the constraints on the inputs to allow the applica-tion of t-fixup in the mixed setup..we present our results on the spider leader-board5 in table 1, where sql-sp trained with dt-fixup outperforms all the other approaches and.
4we use the evaluation script provided in this repo:.
https://github.com/taoyds/spider.
5https://yale-lily.github.io/spider.
table 3 shows the accuracy of our best modelas compared to other approaches7 with differentlevel of hardness deﬁned by yu et al.
(2018).
wecan see that a large portion of the improvement ofour model comes from the medium level on bothdev and test set.
interestingly, while our modelobtains similar performance for the extra hard levelon the dev set, our model performs signiﬁcantlybetter on the unseen test set.
as most of the extra.
6one epoch iterates over the whole training set once.
wanget al.
(2019a) trained with a batch size of 20 for 90,000 steps,which is around 200 epochs on the spider training set.
yuet al.
(2020a) trained with a batch size of 24 for 40, 000 steps,which is around 100 epochs on the spider training set..7we choose the top two submissions which also report the.
breakdown of the accuracy on the test set..2094hard cases involves implicit reasoning steps andcomplicated structures, it shows that our proposedmodels possess stronger reasoning and structuralunderstanding ability, yielding better generalizationover unseen domains and database schemas..achieve better performance than the shallow oneseven there are only thousands of training exam-ples.
it contradicts the common belief that increas-ing depth of the transformer model is helpful onlywhen there are enough training data..5.2 reading comprehension: reclor results.
modelno extra layers∗ (yu et al., 2020b)no extra layers4 extra layers4 extra layers + dt-fixup.
dev62.663.666.266.8.test55.656.258.261.0.table 4: our accuracy on reclor.
star∗ is the best base-line model result reported in (yu et al., 2020b) withoutusing the additional race dataset (lai et al., 2017)..for reclor, we choose the best model in yuet al.
(2020b) as the baseline which employs a lin-ear classiﬁer on top of roberta.
from the re-sults presented in table 4, we can see that simplystacking additional vanilla transformer layers out-performs the baseline and adding dt-fixup furtherimproves the accuracy, which ranks the second onthe public leaderboard at the time of this submis-sion8.
the result further validates the beneﬁt ofadding extra transformer layers and the effective-ness of dt-fixup..5.3 ablation studies.
for fair comparisons and better understanding, weconduct multiple sets of ablation with the samearchitecture and implementation to validate the ad-vantages of dt-fixup over the standard optimiza-tion strategy.
note that, the batch sizes in our exper-iments are relatively small (16 for spider and 24 forreclor) due to the size of the pre-trained models,while batch sizes for masked language modelling(liu et al., 2019b) and machine translation (huanget al., 2020) are commonly larger than 1024..deeper models.
as we can see from table 5, thestandard optimization strategy fails completely totrain deep transformers whose depths are largerthan 8 on both spider and reclor, showing that itstruggles to properly train the transformer modelas the depth increases.
at the same time, dt-fixupcan successfully train deeper transformers up to 32layers and consistently achieves better performancethan models trained by the standard optimizationstrategy with the same depth on both spider andreclor.
with dt-fixup, deep models generally.
8https://eval.ai/web/challenges/challenge-page/503/.
faster convergence.
demonstrated by the vali-dation curves on spider plotted in figure 2, modelstrained with dt-fixup converges to the same levelof performance much faster than models trainedwith the standard optimization strategy.
while stan-dard optimization strategy struggles as the modelsbecome deeper, dt-fixup can keep the model train-ing smooth, showing that dt-fixup can effectivelyaccelerate the convergence of the transformer train-ing, especially for the deep ones..batch sizes when dataset size is small.
asshown in table 7, increasing batch size on spi-der from 16 to 120, the average performance fromﬁve runs drops from 73.24 to 71.08 and the gapwith the standard training approach becomes muchnarrower.
it empirically veriﬁes that large-batchtraining has a negative impact on the generalizationwhen the dataset size is small, conﬁrming the needto stablize small batch training..5.4 source of the improvements.
from the results on the spider benchmark, wecan see signiﬁcant improvements by applying dt-fixup and increasing the depth of the transformermodel.
however, why and where they help text-to-sql semantic parsing are still unclear.
as anattempt to answer these questions, we investigateinto the predicted results from three variants of ourproposed model: baseline, the best model (n = 4)trained with the standard training approach; shal-low, a shallow model (n = 4) trained with dt-fixup; deep, our best model (n = 24) trainedwith dt-fixup, which is much deeper..to better understand the models’ behavior, wemanually examine all the failed cases predicted bythese models and classify the errors into four cat-egories: 1) correct: equivalent in meaning butwith different sql syntax (e.g., order by xlimit 1 and select min(x)); 2) column:the sql structure is correct but there existed mis-predicted columns; 3) sketch: the sql structureis predicted different from the ground truth, whilethe aligned column prediction are correct; 4) both:there exist both sketch and column errors in theprediction.
table 6 presents the overall statisticsof our error analysis.
due to logically equivalent.
2095nspider248162432reclor4816.standard.
dt-fixup.
69.47 ± 0.3070.04 ± 0.3366.86 ± 0.1620.44 ± 1.1119.37 ± 0.1619.57 ± 0.43.
70.73 ± 0.1872.22 ± 0.6173.24 ± 0.5173.52 ± 0.4773.79 ± 0.4973.02 ± 0.52.
64.05 ± 0.4456.96 ± 6.1227.10 ± 1.50.
64.31 ± 0.6865.31 ± 0.6265.68 ± 1.12.table 5: ablation on the number oftransformer layers n .
the means andstandard deviations are reported basedon 5 runs with different random seeds..false neg.
column err.
onlysketch err.
onlyboth err.
all.
base395192124306.shallow deep.
356083105283.
42537788260.table 6: failures in each category..figure 2: validation curves on spider for models trained with differentsettings..figure 3: error breakdown on exam-ples where all models are wrong..figure 4: error breakdown on exam-ples where any model is wrong..model8 extra layers + standard8 extra layers + dt-fixup8 extra layers + dt-fixup.
batch size1616120.acc69.60 ± 0.4073.24 ± 0.5171.08 ± 0.37.table 7: ablation on the batch sizes for the spiderdataset.
to enable large-batch training, we implementthe trick of gradient accumulation at the expense oftraining speed.
the means and standard deviations arereported based on 5 runs with different random seeds..queries, there are a number of false negatives forall three models, conﬁrming that the current spi-der evaluation metric is not ideal.
at ﬁrst glance,the improvements by applying dt-fixup and in-creasing the depth seem to come from correctingsketch and both errors, while the three modelsmake similar number of column only errors.
itprovides evidence that applying dt-fixup and in-creasing the depth can help the transformer modelhandle hard examples which are mispredicted com-pletely (errors in both category) by the baselinemodel.
typically, correct predictions on these hardexamples require a certain level of reasoning andstructural understanding ability..position of error types by each model on mistakenexamples common to all models, as well as on ex-amples where at least one model is wrong.
in fig.
3-4, “column” means “proportion with column er-rors” (i.e., column or both); “sketch” means “pro-portion with sketch errors” (i.e., sketch or both).
there are 190 examples mispredicted by all thethree models and 387 examples which at least oneof the three models mispredict.
fig.
3-4 excludefalse negatives due to equivalent logic queries, wecan see the real improvements from the deep modelare even more signiﬁcant than what the exact matchaccuracy shows.
furthermore, among the commonmistakes to all three models, the deep model hasa much smaller proportion in the sketch mistakeswhich usually involve more logic and structure un-derstanding.
some of column mistakes are dueto missing domain knowledge or common sense,which is harder to improve without external data orknowledge.
this shows that even among the failedcases, deeper transformer model can make morereasonable predictions..6 related work.
fine-grained error analysis.
in order to betterunderstand the errors made, we look into the com-.
many research efforts have been devoted to un-derstanding the training and improving the opti-.
2096mization of the transformer models.
in particu-lar, transformer models often fail to learn unlessa gradual learning rate warm-up is applied at thebeginning of training.
chen et al.
(2018); nguyenand salazar (2019); wang et al.
(2019b) noticed aperformance gap due to layer normalization, andintroduced various architecture changes as remedy.
zhang et al.
(2019b,a); liu et al.
(2020) proposedinitialization schemes to stabilize training, allow-ing either to remove layer normalization or learningrate warmup.
liu et al.
(2019a) demonstrated the in-stability of the adam optimizer during early stagesof optimization.
based on these results, huang et al.
(2020) proposed a weight initialization schema forthe transformer that eliminates the need for layernormalization and warmup completely..7 conclusion.
despite the broad applications of the transformermodel, it struggles to perform well for some nlptasks with limited training data.
in this work, wepropose a theoretically justiﬁed optimization strat-egy dt-fixup to train deeper transformer modelwith improved generalization and faster conver-gence speed on small datasets, which is generallyapplicable to different neural architectures.
ontwo important tasks, text-to-sql semantic pars-ing and logical reading comprehension that requirereasoning and structural understanding, applyingdt-fixup achieves sota or near-sota results bysimplying using extra transformer layers on top ofthe pre-trained models.
such observations suggesteven boarder applicability of deeper transformers..acknowledgements.
we thank all the anonymous reviewers and areachair for their valuable inputs..references.
jimmy lei ba, jamie ryan kiros, and geoffrey e hin-arxiv preprint.
ton.
2016. layer normalization.
arxiv:1607.06450..mia xu chen, orhan firat, ankur bapna, melvinjohnson, wolfgang macherey, george foster, llionjones, mike schuster, noam shazeer, niki parmar,et al.
2018. the best of both worlds: combininginrecent advances in neural machine translation.
proceedings of the 56th annual meeting of the as-sociation for computational linguistics (volume 1:long papers), pages 76–86..jacob devlin, ming-wei chang, kenton lee, andkristina toutanova.
2018. bert: pre-training of deepbidirectional transformers for language understand-ing.
arxiv preprint arxiv:1810.04805..xavier glorot and yoshua bengio.
2010. understand-ing the difﬁculty of training deep feedforward neuralnetworks.
in proceedings of the thirteenth interna-tional conference on artiﬁcial intelligence and statis-tics, pages 249–256..jiaqi guo, zecheng zhan, yan gao, yan xiao,jian-guang lou, ting liu, and dongmei zhang.
2019. towards complex text-to-sql in cross-domaindatabase with intermediate representation.
acl..sepp hochreiter and j¨urgen schmidhuber.
1997.neural computation,.
long short-term memory.
9(8):1735–1780..xiao shi huang, felipe p´erez, jimmy ba, and mak-improving transformer opti-.
sims volkovs.
2020.mization through better initialization.
icml..nitish shirish keskar, dheevatsa mudigere, jorge no-cedal, mikhail smelyanskiy, and ping tak petertang.
2016. on large-batch training for deep learn-ing: generalization gap and sharp minima.
arxivpreprint arxiv:1609.04836..diederik p kingma and jimmy ba.
2014. adam: amethod for stochastic optimization.
arxiv preprintarxiv:1412.6980..guokun lai, qizhe xie, hanxiao liu, yiming yang,and eduard hovy.
2017. race: large-scale read-ing comprehension dataset from examinations.
inproceedings of the 2017 conference on empiricalmethods in natural language processing, pages785–794, copenhagen, denmark.
association forcomputational linguistics..zhenzhong lan, mingda chen, sebastian goodman,kevin gimpel, piyush sharma, and radu soricut.
2019. albert: a lite bert for self-supervised learn-arxiv preprinting of language representations.
arxiv:1909.11942..liyuan liu, haoming jiang, pengcheng he, weizhuchen, xiaodong liu, jianfeng gao, and jiawei han.
2019a.
on the variance of the adaptive learning rateand beyond.
arxiv preprint arxiv:1908.03265..liyuan liu, xiaodong liu, jianfeng gao, weizhuchen, and jiawei han.
2020. understanding the dif-ﬁculty of training transformers.
emnlp..yinhan liu, myle ott, naman goyal, jingfei du, man-dar joshi, danqi chen, omer levy, mike lewis,luke zettlemoyer, and veselin stoyanov.
2019b.
roberta: a robustly optimized bert pretraining ap-proach.
arxiv preprint arxiv:1907.11692..toan q nguyen and julian salazar.
2019. transform-ers without tears: improving the normalization ofself-attention.
arxiv preprint arxiv:1910.05895..2097tao yu, chien-sheng wu, xi victoria lin, bailinwang, yi chern tan, xinyi yang, dragomirradev, richard socher, and caiming xiong.
2020a.
grappa: grammar-augmented pre-training for tablesemantic parsing.
arxiv preprint arxiv:2009.13845..tao yu, rui zhang, kai yang, michihiro yasunaga,dongxu wang, zifan li, james ma, irene li, qingn-ing yao, shanelle roman, et al.
2018. spider: alarge-scale human-labeled dataset for complex andcross-domain semantic parsing and text-to-sql task.
in proceedings of the 2018 conference on empiri-cal methods in natural language processing, pages3911–3921..weihao yu, zihang jiang, yanfei dong, and jiashifeng.
2020b.
reclor: a reading comprehensiondataset requiring logical reasoning.
arxiv preprintarxiv:2002.04326..biao zhang, ivan titov, and rico sennrich.
2019a.
im-proving deep transformer with depth-scaled initial-in proceedings ofization and merged attention.
the 2019 conference on empirical methods in nat-ural language processing and the 9th internationaljoint conference on natural language processing(emnlp-ijcnlp), pages 897–908..hongyi zhang, yann n dauphin, and tengyu ma.
2019b.
fixup initialization: residual learning with-out normalization.
iclr..liang zhao, hexin cao, and yunsong zhao.
2021.gp: context-free grammar pre-training for text-to-sql parsers.
arxiv preprint arxiv:2101.09901..martin popel and ondˇrej bojar.
2018. training tipsfor the transformer model.
the prague bulletin ofmathematical linguistics, 110(1):43–70..alec radford, jeffrey wu, rewon child, david luan,dario amodei, and ilya sutskever.
2019. languagemodels are unsupervised multitask learners.
openaiblog, 1(8):9..peter shaw, jakob uszkoreit, and ashish vaswani.
2018. self-attention with relative position represen-in proceedings of the 2018 conference oftations.
the north american chapter of the association forcomputational linguistics: human language tech-nologies, volume 2 (short papers), pages 464–468..peng shi, patrick ng, zhiguo wang, henghuizhu, alexander hanbo li,jun wang, ciceronogueira dos santos, and bing xiang.
2020. learn-ing contextual representations for semantic pars-ing with generation-augmented pre-training.
arxivpreprint arxiv:2012.10309..nitish srivastava, geoffrey hinton, alex krizhevsky,ilya sutskever, and ruslan salakhutdinov.
2014.dropout: a simple way to prevent neural networksfrom overﬁtting.
the journal of machine learningresearch, 15(1):1929–1958..christian szegedy, vincent vanhoucke, sergey ioffe,jon shlens, and zbigniew wojna.
2016. rethinkingthe inception architecture for computer vision.
inproceedings of the ieee conference on computer vi-sion and pattern recognition, pages 2818–2826..ashish vaswani, noam shazeer, niki parmar, jakobuszkoreit, llion jones, aidan n gomez, łukaszkaiser, and illia polosukhin.
2017. attention is allin advances in neural information pro-you need.
cessing systems, pages 5998–6008..bailin wang, richard shin, xiaodong liu, olek-sandr polozov, and matthew richardson.
2019a.
rat-sql: relation-aware schema encoding andarxiv preprintlinking for text-to-sql parsers.
arxiv:1911.04942..qiang wang, bei li, tong xiao,.
jingbo zhu,changliang li, derek f wong, and lidia s chao.
2019b.
learning deep transformer models for ma-chine translation.
in proceedings of the 57th annualmeeting of the association for computational lin-guistics, pages 1810–1822..hongfei xu, qiuhui liu, josef van genabith, deyixiong, and jingyi zhang.
2019. lipschitz con-strained parameter initialization for deep transform-ers.
arxiv preprint arxiv:1911.03179..pengcheng yin and graham neubig.
2018. tranx: atransition-based neural abstract syntax parser for se-mantic parsing and code generation.
arxiv preprintarxiv:1810.02720..2098a full prooftheorem 3.1 assuming (cid:107)xxx(cid:107) = θ(µ) for some µ (cid:29) 1, then (cid:107) ∂fg∂θθθg.
(cid:16).
(cid:16).
θ.θ.
((4µ2 + 2µ + 2)n )− 1(cid:17)(4µ2n )− 1.
2.
2.
(cid:17).
in the case of vanilla transformers..for all encoder layers l in relational transformers; and (cid:107)vl(cid:107) = (cid:107)wl(cid:107) =.
(cid:107) = θ(1) if (cid:107)vl(cid:107) = (cid:107)wl(cid:107) = (cid:107)rv.
l (cid:107) =.
proof.
first, let’s inspect the feedforward pass through the transformer blocks, which have nonlinearlayers gl’s and skip connections: xxx1 = xxx;.
.
.
; xxxl+1 = xxxl + gl(xxxl, θθθl) forl%2 = 1 (i.e.
odd layers), gl is a (relational) self-attention layer, whereas for even layers, gl is a mlplayer.
using θ= to denote bounded in norm as in huang et al.
(2020), then at initialization:.
xxx2 = xxx1 + g1(xxx1, θθθ1);.
xxxl+1xxxl+1.
θ= xxxl + vlwlxxxl + wlrvlθ= xxxl + vlwlxxxl.
for relational self-attention.
for vanilla self-attention and mlp.
(9).
(10).
θ= 1 + vlwl and ∂gl∂xxxl.
this is due to the fact that the probability from softmax sums to one, so does not alter the overall norm;at initialization, values are at the linear identity range of the nonlinearities.
therefore, for all threetypes of layers: ∂xxxl+1θ=∂xxxl[wlxxxl, vlxxxl + rvl , wl, 000], where 000 are due to q, k, rrrk which appear only inside the softmax and do notasymptotically affect the norm.
and for vanilla self-attention and mlp, ∂xxxl+1θ= [wlxxxl, vlxxxl, 000].
∂θθθlnext, let’s look at ∂fg∂θθθgfg(xxx, θθθg) = xxx1 + g1(xxx1, θθθ1) + g2(xxx2, θθθ2) + .
.
.
+ gl(xxx2, θθθl).
θ= vlwl.
and for relational self-attention: ∂xxxl+1∂θθθl.
].
first note that:.
, .
.
.
, ∂fg∂θθθl.
, .
.
.
, ∂fg∂θθθl.
= [ ∂fg∂θθθ1.
= ∂gl∂θθθl.
= ∂gl∂θθθl.
(11).
working backwards, for the last layer, ∂fg∂θθθl.
= ∂gl∂θθθl.
.
for ∂fg∂θθθl.
, terms with index lower than l vanish, so:.
∂fg/∂θθθl = ∂gl/∂θθθl + ∂gl+1/∂xxxl+1∂xxxl+1/∂θθθl + .
.
.
+ ∂gl/∂xxxl∂xxxl/∂xxxl−1 .
.
.
∂xxxl+1/∂θθθlθ= (1 + vl+1wl+1 + .
.
.
+ vlwl(1 + vl−1wl−1) .
.
.
(1 + vl+1wl+1)) ∂gl/∂θθθl.
(12).
(13).
assuming v1.
θ= v2 .
.
.
θ= vl and w1.
θ= w2 .
.
.
θ= wl, and both (cid:28) 1, then the above reduces to:.
∂fg/∂θθθl.
θ= (1 + (l − l)vlwl)∂gl/∂θθθl.
recall that we want to bound ∂fg∂θθθg.
∂fg∂θθθg.
(cid:62).
= (cid:80)l.(cid:62).
∂fg∂θθθl.
∂fg∂θθθl.
.
for vanilla self-attention or mlp layers:.
(cid:62).
∂fg∂θθθl.
∂fg∂θθθl.
θ= (cid:0)(cid:107)wl(cid:107)2(cid:107)xxxl(cid:107)2 + (cid:107)vl(cid:107)2(cid:107)xxxl(cid:107)2(cid:1) (1 + (l − l)(cid:107)vl(cid:107)(cid:107)wl(cid:107))2.and for relational self-attention:.
(cid:62).
∂fg∂θθθl.
∂fg∂θθθl.
θ=(cid:0)(cid:107)wl(cid:107)2(cid:107)xxxl(cid:107)2+(cid:107)vl(cid:107)2(cid:107)xxxl(cid:107)2+2(cid:107)vl(cid:107)(cid:107)xxxl(cid:107)(cid:107)rv.
l (cid:107)+(cid:107)rv.
l (cid:107)2+(cid:107)wl(cid:107)2(cid:1) (1+(l−l)(cid:107)vl(cid:107)(cid:107)wl(cid:107))2.
(16).
at initialization, we want vl, wl, rv(cid:107)vj(cid:107) θ= (cid:107)wj(cid:107) θ= (cid:107)rvtransformer blocks, with each block containing two layers, so that 2n = l. so we have:.
l (cid:107) θ=j (cid:107) for all l and j, so denoting them using ξ. and recall that n is the number of.
l of all layers to have the same norm, i.e.
(cid:107)vl(cid:107) θ= (cid:107)wl(cid:107) θ= (cid:107)rv.
∂fg∂θθθg.
∂fg∂θθθg.
(cid:62)θ= (cid:80).
(cid:0)2ξ2(cid:107)xxxl(cid:107)2(cid:1) (cid:0)1+(l−l)ξ2(cid:1)+(cid:80).
(cid:0)2ξ2(cid:107)xxxl(cid:107)2 +2ξ2(cid:107)xxxl(cid:107)+2ξ2(cid:1)(cid:0)1+(l−l)ξ2(cid:1).
l%2=1.
l%2=0.
θ= (cid:80)nl=1.
(cid:0)4ξ2(cid:107)xxxl(cid:107)2 + 2ξ2(cid:107)xxxl(cid:107) + 2ξ2(cid:1) (1 + (2n − l)ξ2).
similarly if fg is vanilla transformer instead of a relational one, we have:(cid:62).
∂fg∂θθθg.
∂fg∂θθθg.
θ= (cid:80)nl=1.
(cid:0)4ξ2(cid:107)xxxl(cid:107)2(cid:1) (1 + (2n − l)ξ2).
(14).
(15).
(17).
(18).
2099the only variable that still depends on l is xxxl, which by expanding the recursion in eq.
9-10, gives:.
xxxlxxxl.
θ= (1 + ξ2)lxxx θ= (1 + lξ2 + θ(ξ4))xxxfor vanillla transformerθ= (1 + ξ2)lxxx + l/2ξ2 θ= (1 + lξ2 + θ(ξ4))xxx + l/2ξ2 for relational transformer.
(19).
(20).
now let (cid:107)xxx(cid:107) θ= µ , and we have assumed that µ (cid:29) 1, which is very common for output of pre-trainedencoders, and due to the high dimensionality.
and let.
ξ = (cid:0)n (4µ2 + 2µ + 2)(cid:1)− 1.
2.
(21).
then substituting it into eq.
19-20, we have xxxlthe expression (1 + (2n − l)ξ2) in eq.
17 yields (1 + (2n − l)ξ2) θ= 1, together with xxxl21, eq.
17 becomes:.
θ= xxx for all types of layers.
similarly, plugging eq.
21 intoθ= xxx, and eq..(cid:62).
∂fg∂θθθg.
∂fg∂θθθg.
θ= (cid:80)nl=1.
4µ2n (4µ2 + 2µ + 2).
+.
2µn (4µ2 + 2µ + 2).
+.
2n (4µ2 + 2µ + 2).
θ= (cid:80)n.l=11/n = θ(1).
this concludes the proof for relational transformers.
for vanilla transformers, with ξ = (cid:0)n (4µ2)(cid:1)− 12 ,and following the same steps, but plugging into eq.
18, we have ∂fgq.e.d.
∂θθθg.
(cid:62) θ= 1..∂fg∂θθθg.
b proof of theorem 3.2for brevity, we drop the layer index.
but for the relation embeddings, for clarity, we will consider theindividual components of rrrv, rrrk instead of considering the scalar case..proof.
we will focus the self-attention layer, as the skip connection and mlp layers are analyzed inhuang et al.
(2020).
as mentioned in the main text, since what we care is the magnitude of the update,we assume dx = 1 and drop layer index l without loss of generality.
in this case, the projection matricesqqq, kkk, vvv, www reduce to scalars q, k, v, w ∈ r. the input xxx and the relational embeddings rrrk, rrrv are n × 1vectors.
for a single query input x(cid:48) ∈ xxx, the attention layer (without skip connection) is deﬁned as follows:.
g(x(cid:48)) = softmax.
x(cid:48)q(kxxx + rrrk)(cid:62).
(xxxv + rrrv)w = (cid:80)n.(cid:19).
(cid:18) 1√dx.
ex(cid:48)q(kxi+rki )j=1ex(cid:48)q(kxj +rkj ).
i=1.
(cid:80)n.(xiv + rv.
i )w.note that we are abusing the notation and take g to be just the self-attention layer output here.
letsi = ex(cid:48)q(kxi+rk.
j ) and δij = 1 if i = j and 0 otherwise, we can get:.
i )/(cid:80)n.j=1ex(cid:48)q(kxj +rk.
i )si(cid:16).
(cid:16).
xi − (cid:80)n.(cid:17).
j=1xjsji − (cid:80)n.∂g/∂k = x(cid:48)qw(cid:80)n.i=1(xiv + rv.
∂g/∂q = x(cid:48)w(cid:80)ni=1(xiv + rv(cid:16).
−(xiv + rv.
∂g/∂rki = x(cid:48)qw∂g/∂w = (cid:80)n.kxi + rk.
i )sii )si + (cid:80)ni )si ; ∂g/∂rv.
i=1(xiv + rv.
(cid:17).
j=1(kxj + rk(cid:17).
j )sj.
j=1(xjv + rv.
; ∂g/∂v = w(cid:80)ni = wsi ; ∂g/∂xi = vwsi + w(cid:80)n.j )sj.
i=1xisij=1∂sj/∂xi(xjv + rvj ).
when xiq (cid:0)(1 + δij)kxi + rksgd update ∆g is proportional to the magnitude of the gradient:.
(cid:54)= x(cid:48), we have:(cid:1) sj − (cid:80)n.t=1q (cid:0)(1 + δit)kxt + rk.
= sj(δij − si)x(cid:48)qk; when xi = x(cid:48), we have:.
=(cid:1) sjst using taylor expansion, we get that the.
t.i.
∂sj∂xi.
∂sj∂xi.
(cid:32).
∆g = −η.
∂l∂g.
(cid:62).
∂g∂k.
∂g∂k.
+.
∂g∂q.
∂g∂q.
(cid:62).
(cid:62).
∂g∂v.
∂g∂v.
+.
∂g∂w.
+.
(cid:62).
(cid:62).
∂g∂w(cid:62)(cid:33).
+(cid:80)n.i=1.
(cid:62).
∂g∂rki.
∂g∂rki.
+ (cid:80)n.i=1.
∂g∂rvi.
∂g∂rvi.
+ (cid:80)n.i=1.
∂g∂xi.
∂g∂xi.
+ o(η2).
2100by the assumption that (cid:107)η ∂l∂g (cid:107) = θ(η), we need to bound the term inside the main parentheses byθ(1/l).
the desired magnitude θ(1/l) is smaller than 1 so terms with lower power are dominating.
with si ≥ 0 and (cid:80)si = 1, the following terms have the lowest power inside the main parentheses:.
= w2((cid:80)n.i=1xisi)2 = θ((cid:107)w(cid:107)2(cid:107)xi(cid:107)2), i = 1, .
.
.
, n.= ((cid:80)n.i=1(xiv + rv.
i )si)2 = θ((cid:107)v(cid:107)2(cid:107)xi(cid:107)2) + 2θ((cid:107)v(cid:107)(cid:107)rv.
i (cid:107)(cid:107)xi(cid:107)) + θ((cid:107)rv.
i (cid:107)2), i = 1, .
.
.
, n.(cid:62).
(cid:62).
(cid:62).
∂g∂v∂g∂w∂g∂rvi.
∂g∂v∂g∂w∂g∂rvi.
(cid:80)n.i=1.
= w2(cid:80)n.i=1s2.
i = θ((cid:107)w(cid:107)2)..for the mlp layer, all terms related to rvi disappear, including the single θ((cid:107)w(cid:107)2) in the last row.
bycombining the update norm terms from both the self-attention and the mlp layers give the result.
q.e.d.
note: the above theorem and analysis applies to a single layer, not the whole transformer module ofmany layers.
in order to derive the scaling factor, one needs ensure that the output scale for each block isbounded by its input scale.
this indeed holds for our scheme, but the complete proof is in sec.
a..c implementation details of sql-spgiven a schema s for a relational database, our goal is to translate the natural question q to the targetsql t .
here the question q = q1 .
.
.
q|q| is a sequence of words, and the schema s = {s1, .
.
.
, s|s|}consists of tables and their columns.
s ∈ s can be either a table name or a column name containingwords si,1, .
.
.
, si,|si|.
following wang et al.
(2019a), a directed graph g = (cid:104)v, e(cid:105) can be constructed torepresent the relations between the inputs.
its nodes v = q ∪ s include question tokens (each labeledwith a corresponding token) and the columns and tables of the schema (each labeled with the words in itsname).
the edges e are deﬁned following wang et al.
(2019a).
the target sql t is represented as anabstract syntax tree in the context-free grammar of sql..c.1 encoderfollowing (wang et al., 2019a; guo et al., 2019), our pre-transformer module fe leverages pre-trainedlanguage models to obtain the input x to the main transformer module.
first, the sequence of words inthe question q are concatenated with all the items (either a column or a table) in the schema s. in orderto prevent our model from leveraging potential spurious correlations based on the order of the items, theitems in the schema are concatenated in random order during training.
we feed the concatenation into thepre-trained model and extract the last hidden states xxx(q)and hhhi = hhhi,1, .
.
.
, hhhi,|si| for each word in q andieach item in s respectively.
for each item si in the schema, we run an additional bidirectional lstm(bilstm) (hochreiter and schmidhuber, 1997) over the hidden states of the words in its name hhhi.
wethen add the average hidden state and the ﬁnal hidden state of the bilstm as the schema representationsxxx(s)1 , .
.
.
, xxx(s)|s|).
ialong with the relational embeddings rrrk, rrrv speciﬁed by g, x is passed into the main transformer module...
x is the set of all the obtained representations from q ∪ s: x = (xxx(q).
1 , .
.
.
, xxx(q).
|q|, xxx(s).
c.2 schema linkingthe goal of schema linking is to identify the implicit relations between q and s. the relations aredeﬁned by whether there exist column/table references in the question to the corresponding schemacolumns/tables, given certain heuristics.
following wang et al.
(2019a), possible relations for each (i, j)where xi ∈ q, xj ∈ s (or vice versa) can be exactmatch, partialmatch, or nomatch, whichare based on name-based linking.
depending on the type of xi and xj, the above three relations arefurther expanded to four types: question-column, question-table, column-question, ortable-question.
we also use the value-based linking from wang et al.
(2019a) and guo et al.
(2019)to augment the exactmatch relation by database content and external knowledge..c.3 decoderfor our decoder (as the post-transformer module) fo, we employ a transition-based abstract syntax decoderfollowing yin and neubig (2018).
it requires a transition system to converts between the surface sqland a ast-tree constructing action sequences, and can ensure grammarticality of generation.
the neuralmodel then predicts the action sequences.
there are three types of actions to generate the target sql t ,.
2101including (i) applyrule which applies a production rule to the last generated node; (ii) reduce whichcompletes a leaf node; (iii) selectcolumn which chooses a column from the schema.
for our transitionsystem, each column is attached with their corresponding table so that the tables in the target sql tcan be directly inferred from the predicted columns.
as a result, action selecttable can be omittedfrom the generation.
formally, the generation process can be formulated as pr(t |y) = (cid:81)t pr(at|a<t, y)where y is the outputs of the last layer of the relational transformers.
we use a parent-feeding lstmas the decoder.
the lstm state is updated as mmmt, hhht = flstm([aaat−1(cid:107)zzzt−1(cid:107)hhhpt(cid:107)aaapt(cid:107)nnnpt], mmmt−1, hhht−1),where mmmt is the lstm cell state, hhht is the lstm output at step t, aaat−1 is the action embedding of theprevious step, zzzt−1 is the context feature computed using multi-head attention on hhht−1 over y, pt is thestep corresponding to the parent ast node of the current node, and nnn is the node type embedding.
forapplyrule[r], we compute pr(at = applyrule[r]|a<t, y) = softmaxr(g(zzzt)) where g(·) is a2-layer mlp.
for selectcolumn, we use the memory augmented pointer net guo et al.
(2019)..c.4 regularizationbesides using dropout (srivastava et al., 2014) employed on x and zzzt to help regularize the model,we further apply uniform label smoothing (szegedy et al., 2016) on the objective of predictingselectcolumn.
formally, the cross entropy for a ground-truth column c∗ we optimize becomes:(1 − (cid:15)) ∗ log p(c∗) + (cid:15)/k ∗ (cid:80)c log p(c), where k is the number of columns in the schema, (cid:15) is the weightof the label smoothing term, and p(·) (cid:44) pr(at = selectcolumn[·]|a<t, y).
c.5 experiment conﬁgurationwe choose roberta (liu et al., 2019b) as the pre-trained language models.
a sequence of 24 relation-aware transformer layers are stacked on top of fe.
the adam optimizer (kingma and ba, 2014) with thedefault hyperparameters is used to train the model with an initial learning rate η of 4 × 10−4.
η is annealedto 0 with 4 × 10−4(1 − steps/max steps)0.5. a separate learning rate is used to ﬁne-tune the robertaby multiplying η a factor of 8 × 10−3.
the bilstm to encode the schema representations has hiddensize 128 per direction.
for each transformer layer, dx = dz = 256, h = 8 and the inner layer dimensionof the position-wise mlp is 1024. for the decoder, we use action embeddings of size 128, node typeembeddings of size of 64, and lstm hidden state of size 512. we apply dropout rate of 0.6 on the inputto the relational transformers x and the context representation zzzt.
the weight of the label smoothing termis set to be 0.2. we use a batch size of 16 and train 60 epochs (around 25, 000 steps).
during inference,beam search is used with beam size as 5. most of the hyperparameters are chosen following wang et al.
(2019a).
we only tune the learning rate (4 × 10−4 to 8 × 10−4 with step size 1 × 10−4), dropout (0.3,0.4, 0.5, 0.6), the weight of the label smoothing (cid:15) (0.0, 0.1, 0.2) by grid search.
the average runtime isaround 30 hours and the number of parameters is around 380 millions..d implementation details for logical reading comprehensionwe build on the code9 by yu et al.
(2020b) and use it for evaluation.
for each example, the encoderembeds the input context, question and options which are then passed to the linear layer for classiﬁcation.
the exact input format to the encoder is “(cid:104)s(cid:105) context (cid:104)/s(cid:105)(cid:104)/s(cid:105) question || option (cid:104)pad(cid:105) .
.
.
”, where “||”denotes concatenation.
the linear layer uses the embedding of the ﬁrst token (cid:104)s(cid:105) for classiﬁcation..d.1 experimental conﬁgurationrobert is chosen as the pre-trained model, and we stack 4 transformer layers on top.
the adamoptimizer (kingma and ba, 2014) with (cid:15) = 10−6 and betas of (0.9, 0.98) is used.
the learning rate toﬁnetune roberta is 1 × 10−5 while the learning rate for the additional transformer layers is 3 × 10−4.
for all models in our ablation study, the learning rate for the additional transformer layers is 1 × 10−4.
thelearning rate is annealed linearly to 0 with weight decay of 0.01. we use a batch size of 24 and ﬁne-tunefor 12 epochs.
for each transformer layer, dx = dz = 1024, h = 8 and the inner layer dimension of theposition-wise mlp is 2048. we use dropout rate of 0.4 on the input to the additional transformer layersand 0.1 for the linear layer.
we follow the hyperparameters used in yu et al.
(2020b) for the pretrainedlanguage model.
for the additional transformer layers, we only tune the dropout values (0.3, 0.4, 0.5, 0.6).
the average runtime is around 6 hours and the number of parameters is around 39 millions..9https://github.com/yuweihao/reclor.
2102